<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-ietf-ntp-using-nts-for-ntp-12"
     ipr="trust200902" submissionType="IETF">
  <front>
    <title abbrev="NTS4NTP">Network Time Security for the Network Time
    Protocol</title>

    <author fullname="Daniel Fox Franke" initials="D." surname="Franke">
      <address>
        <email>dfoxfranke@akamai.com</email>
        <uri>https://www.dfranke.us</uri>
      </address>
    </author>

    <author fullname="Dieter Sibold" initials="D." surname="Sibold">
      <organization abbrev="PTB">Physikalisch-Technische
      Bundesanstalt</organization>

      <address>
        <postal>
          <street>Bundesallee 100</street>

          <city>Braunschweig</city>

          <code>D-38116</code>

          <region/>

          <country>Germany</country>
        </postal>

        <phone>+49-(0)531-592-8420</phone>

        <facsimile>+49-531-592-698420</facsimile>

        <email>dieter.sibold@ptb.de</email>
      </address>
    </author>

    <author fullname="Kristof Teichel" initials="K." surname="Teichel">
      <organization abbrev="PTB">Physikalisch-Technische
      Bundesanstalt</organization>

      <address>
        <postal>
          <street>Bundesallee 100</street>

          <city>Braunschweig</city>

          <region/>

          <code>D-38116</code>

          <country>Germany</country>
        </postal>

        <phone>+49-(0)531-592-4471</phone>

        <facsimile/>

        <email>kristof.teichel@ptb.de</email>

        <uri/>
      </address>
    </author>

    <date day="05" month="March" year="2018"/>

    <area>Internet Area</area>

    <workgroup>NTP Working Group</workgroup>

    <keyword>Integrity</keyword>

    <keyword>Authentication</keyword>

    <keyword>NTP</keyword>

    <keyword>Security</keyword>

    <abstract>
      <t>
        This memo specifies Network Time Security (NTS), a mechanism for using
        Transport Layer Security (TLS) and Authenticated Encryption with
        Associated Data (AEAD) to provide cryptographic security for the
        client-server mode of the Network Time Protocol (NTP).
      </t>
      <t>
        NTS is structured as a suite of two loosely coupled sub-protocols: the
        NTS Key Establishment Protocol (NTS-KE) and the NTS Extension Fields for
        NTPv4. NTS-KE handles NTS service authentication, initial handshaking,
        and key extraction over TLS. Encryption and authentication during NTP
        time synchronization is performed through the NTS Extension Fields in
        otherwise standard NTP packets. Except for during the initial NTS-KE
        process, all state required by the protocol is held by the client in
        opaque cookies.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
	This memo specifies Network Time Security (NTS), a
	cryptographic security mechanism for network time
	synchronization. A complete specification is provided for
	application of NTS to the client-server mode of the
  <xref target="RFC5905">Network Time Protocol (NTP)</xref>.
      </t>

      <section title="Objectives">
	<t>
	  The objectives of NTS are as follows:

	  <list style="symbols">
	    <t>
        Identity: Through the use of the X.509 public key infrastructure,
        implementations may cryptographically establish the identity of
        the parties they are communicating with.
	    </t>
	    <t>
	      Authentication: Implementations may cryptographically
	      verify that any time synchronization packets are
	      authentic, i.e., that they were produced by an
	      identified party and have not been modified in transit.
	    </t>
	    <t>
	      Confidentiality: Although basic time synchronization
	      data is considered non-confidential and sent in the
	      clear, NTS includes support for encrypting NTP extension
	      fields.
	    </t>
	    <t>
	      Replay prevention: Client implementations may detect when
	      a received time synchronization packet is a replay of
	      a previous packet.
	    </t>
	    <t>
	      Request-response consistency: Client implementations may
	      verify that a time synchronization packet received from
	      a server was sent in response to a particular request from
	      the client.
	    </t>
	    <t>
	      Unlinkability: For mobile clients, NTS will not leak any
	      information additional to NTP which would permit a passive adversary to
	      determine that two packets sent over different networks
	      came from the same client.
	    </t>
	    <t>
        Non-amplification: Implementations (especially server
        implementations) may avoid acting as distributed
        denial-of-service (DDoS) amplifiers by never responding to a
        request with a packet larger than the request packet.
	    </t>
	    <t>
	      Scalability: Server implementations may serve large
	      numbers of clients without having to retain any
	      client-specific state.
	    </t>
	  </list>
	</t>
      </section>

      <section title="Protocol overview">
	<t>
	  The Network Time Protocol includes many different operating
	  modes to support various network topologies. In addition to
	  its best-known and most-widely-used client-server mode, it
	  also includes modes for synchronization between symmetric
	  peers, a control mode for server monitoring and administration
	  and a broadcast mode. These various modes have differing and
	  partly contradictory requirements for security and
	  performance. Symmetric and control modes demand mutual
	  authentication and mutual replay protection, and for certain
	  message types control mode may require confidentiality as well
	  as authentication. Client-server mode places more stringent
	  requirements on resource utilization than other modes, because
	  servers may have vast number of clients and be unable to
	  afford to maintain per-client state. However, client-server
	  mode also has more relaxed security needs, because only the
	  client requires replay protection: it is harmless for stateless servers
	  to process replayed packets. The security demands of symmetric
	  and control modes, on the other hand, are in conflict with the
	  resource-utilization demands of client-server mode: any scheme
	  which provides replay protection inherently involves
	  maintaining some state to keep track of what messages have
	  already been seen.
	</t>

	<t>
	  This memo specifies NTS exclusively for the client-server mode
    of NTP. To this end, NTS is structured as a suite of two protocols:

	  <list>
	    <t>
	      The "NTS Extension Fields for NTPv4" are a collection of
	      NTP extension fields for cryptographically securing
	      NTPv4 using previously-established key material. They
	      are suitable for securing client-server mode because the
	      server can implement them without retaining per-client
	      state, but on the other hand are suitable *only* for
	      client-server mode because only the client, and not the
	      server, is protected from replay.
	    </t>

	    <t>
        The &quot;NTS Key Establishment&quot; protocol (NTS-KE)
        is a mechanism for establishing key material for use with
        the NTS Extension Fields for NTPv4. It uses TLS to
        exchange keys and negotiate some additional protocol
        options, but then quickly closes the TLS channel and
        permits the server to discard all associated state.
      </t>
	  </list>
	</t>

	<t>
	  The typical protocol flow is as follows.
    The client connects to the server on the NTS TCP
	  port and the two parties perform a TLS handshake. Via the TLS
	  channel, the parties negotiate some additional protocol
	  parameters and the server sends the client a supply of
	  cookies.  The parties use <xref target="RFC5705">TLS key
	  export</xref> to extract key material which will be used in
	  the next phase of the protocol.  This negotiation takes only a
	  single round trip, after which the server closes the
	  connection and discards all associated state. At this point
	  the NTS-KE phase of the protocol is complete.
	</t>
	<t>
	  Time synchronization proceeds over the NTP UDP port. The
	  client sends the server an NTP client packet which includes
	  several extension fields. Included among these fields are a
	  cookie (previously provided by the server), and an
	  authentication tag, computed using key material extracted from
	  the NTS-KE handshake. The server uses the cookie to recover
	  this key material (previously discarded to avoid maintaining
	  state) and sends back an authenticated response. The response
	  includes a fresh, encrypted cookie which the client then sends
	  back in the clear with its next request. (This constant
	  refreshing of cookies is necessary in order to achieve NTS's
	  unlinkability goal.)
	</t>
      </section>
    </section>

    <section title="Requirements Language">
      <t>
	The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
	NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
	"OPTIONAL" in this document are to be interpreted as described
	in <xref target="RFC2119">RFC 2119</xref>.
      </t>
    </section>

    <section title="TLS profile for Network Time Security" anchor="tls-profile">
      <t>
        Network Time Security makes use of TLS for NTS key establishment.
      </t>
      <t>
        Since securing time protocols is (as of 2017) a novel
        application of TLS, no backward-compatibility concerns exist
        to justify using obsolete, insecure, or otherwise broken TLS
        features or versions. We therefore put forward the following
        requirements and guidelines, roughly representing 2017's best
        practices.
      </t>
      <t>
        Implementations MUST NOT negotiate TLS versions
        earlier than 1.2.
      </t>
      <t>
        Implementations willing to negotiate more than one possible
        version of TLS SHOULD NOT respond to handshake failures by
        retrying with a downgraded protocol version. If they do, they
        MUST implement <xref target="RFC7507"/>.
      </t>
      <t>
        TLS clients MUST NOT offer, and TLS servers MUST NOT select,
        RC4 cipher suites. <xref target="RFC7465"/>
      </t>
      <t>
        TLS 1.2 clients SHOULD offer, and TLS servers SHOULD accept, the
        <xref target="RFC5746">TLS Renegotiation Indication
        Extension</xref>. Regardless, they MUST NOT initiate or permit
        insecure renegotiation.
      </t>
      <t>
        TLS 1.2 clients SHOULD offer, and TLS 1.2 servers SHOULD accept, the
        <xref target="RFC7627">TLS Session Hash and Extended Master
        Secret Extension</xref>.
      </t>
      <t>
        Use of the <xref target="RFC7301">Application-Layer Protocol
        Negotiation Extension</xref> is integral to NTS and support for
        it is REQUIRED for interoperability.
      </t>
    </section>

    <section title="The NTS Key Establishment protocol">
      <t>
        The NTS key establishment protocol is conducted via TCP port
        [[TBD1]].  The two endpoints carry out a TLS handshake in
        conformance with <xref target="tls-profile"/>, with the client
        offering (via an <xref target="RFC7301">ALPN</xref>
        extension), and the server accepting, an application-layer
        protocol of &quot;ntske/1&quot;.  Immediately following a
        successful handshake, the client SHALL send a single request
        (as Application Data encapsulated in the TLS-protected
        channel), then the server SHALL send a single response
        followed by a TLS "Close notify" alert and then discard the
        channel state.
      </t>
      <t>
        The client's request and the server's response each SHALL
        consist of a sequence of records formatted according to <xref
        target="ntske-record"/>. The sequence SHALL be terminated by a
        &quot;End of Message&quot; record, which has a Record Type of
        zero and a zero-length body. Furthermore, requests and
        non-error responses each SHALL include exactly one NTS Next
        Protocol Negotiation record.
      </t>
      <t>
	Clients and servers MAY enforce length limits on requests
	and responses, however servers MUST accept requests of
	at least 1024 octets, and clients SHOULD accept responses
	of at least 65536 octets.
      </t>
      <figure anchor="ntske-record">
        <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|C|         Record Type         |          Body Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
.                                                               .
.                           Record Body                         .
.                                                               .
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]>
        </artwork>
      </figure>
      <t>
        The requirement that all NTS-KE messages be terminated by an
        End of Message record makes them self-delimiting.
      </t>
      <t>
        The fields of an NTS-KE record are defined as follows:
        <list>
          <t>
            C (Critical Bit): Determines the disposition of
            unrecognized Record Types. Implementations which receive a
            record with an unrecognized Record Type MUST ignore the
            record if the Critical Bit is 0, and MUST treat it as an
            error if the Critical Bit is 1.
          </t>
          <t>
            Record Type: A 15-bit integer in network byte order. The
            semantics of record types 0&ndash;5 are specified in this
            memo; additional type numbers SHALL be tracked through the
            IANA Network Time Security Key Establishment Record Types
            registry.
          </t>
          <t>
            Body Length: The length of the Record Body field, in
            octets, as a 16-bit integer in network byte order. Record
            bodies MAY have any representable length and need not be
            aligned to a word boundary.
          </t>
          <t>
            Record Body: The syntax and semantics of this field SHALL
            be determined by the Record Type.
          </t>
        </list>
      </t>
      <t>
	For clarity regarding bit-endianness: the Critical Bit is the
	most-significant bit of the first octet. In C, given a network
	buffer `unsigned char b[]` containing an NTS-KE record, the
	critical bit is `b[0] &gt;&gt; 7` while the record type is
	`((b[0] &amp; 0x7f) &lt;&lt; 8) + b[1]`.
      </t>
      <t>
       <xref target="fig_NTSKeyExchange"/> provides a schematic
       overview of the key exchange. It displays the protocol
       steps to be performed by the NTS client and server and
       record types to be exchanged.
      <figure anchor="fig_NTSKeyExchange" title="NTS Key Exchange messages">
          <artwork><![CDATA[                +---------------------------------------+
                | - verify client request message       |
                | - extract TLS key material            |
                | - generate KE response message        |
                |   - included Record Types:            |
                |       - NTS Next Protocol Negotiation |
                |       - AEAD Alg. Negotiation         |
                |       - New Cookie for NTPv4          |
                |       - <New Cookie for NTPv4>        |
                |       - End of Message                |
                +-----------------+---------------------+
                                  |
                                  |
Server -----------+---------------+-----+----------------------->
                  ^                      \
                 /                        \
                /    TLS application       \
               /     data                   \
              /                              \
             /                                V
Client -----+---------------------------------+---------------->
            |                                 |
            |                                 |
            |                                 |
+-----------+----------------------+   +------+-----------------+
|- generate KE request message     |   |- verify server response|
| - include Record Types:          |   |  message               |
|  o NTS Next Protocol Negotiation |   |- extract cookie(s)     |
|  o AEAD Alg. Negotiation         |   |                        |
|  o End of Message                |   |                        |
+----------------------------------+   +------------------------+

]]></artwork>
      </figure>
      </t>
      <section title="NTS-KE Record Types">
        <t>The following NTS-KE Record Types are defined.</t>
        <section title="End of Message">
          <t>
            The End of Message record has a Record Type number of 0
            and an zero-length body. It MUST occur exactly once as the
            final record of every NTS-KE request and response. The
            Critical Bit MUST be set.
          </t>
        </section>
        <section title="NTS Next Protocol Negotiation">
          <t>
            The NTS Next Protocol Negotiation record has a Record Type
            of 1. It MUST occur exactly once in every NTS-KE request
            and response. Its body consists of a sequence of 16-bit
            unsigned integers in network byte order. Each integer
            represents a Protocol ID from the IANA Network Time
            Security Next Protocols registry. The Critical Bit MUST be
            set.
          </t>
          <t>
            The Protocol IDs listed in the client's NTS Next
            Protocol Negotiation record denote those protocols which
            the client wishes to speak using the key material
            established through this NTS-KE session. The Protocol
            IDs listed in the server's response MUST comprise a
            subset of those listed in the request, and denote those
            protocols which the server is willing and able to speak
            using the key material established through this NTS-KE
            session. The client MAY proceed with one or more of
            them. The request MUST list at least one protocol, but the
            response MAY be empty.
          </t>
        </section>
        <section title="Error">
          <t>
            The Error record has a Record Type number of 2. Its body
            is exactly two octets long, consisting of an unsigned
            16-bit integer in network byte order, denoting an error
            code. The Critical Bit MUST be set.
          </t>
          <t>
            Clients MUST NOT include Error records in their request.
            If clients receive a server response which includes an
            Error record, they MUST discard any negotiated key
            material and MUST NOT proceed to the Next Protocol.
          </t>
          <t>
            The following error codes are defined.
            <list>
              <t>
                Error code 0 means &quot;Unrecognized Critical
                Record&quot;. The server MUST respond with this error
                code if the request included a record which the server
                did not understand and which had its Critical Bit
                set. The client SHOULD NOT retry its request without
                modification.
              </t>
              <t>
                Error code 1 means &quot;Bad Request&quot;. The server
                MUST respond with this error if, upon the expiration
                of an implementation-defined timeout, it has not yet
                received a complete and syntactically well-formed
                request from the client. This error is likely to be
                the result of a dropped packet, so the client SHOULD
                start over with a new TLS handshake and retry its
                request.
              </t>
            </list>
          </t>
        </section>
        <section title="Warning">
          <t>
            The Warning record has a Record Type number of 3. Its body
            is exactly two octets long, consisting of an unsigned
            16-bit integer in network byte order, denoting a warning
            code. The Critical Bit MUST be set.
          </t>
          <t>
            Clients MUST NOT include Warning records in their request.
            If clients receive a server response which includes a
            Warning record, they MAY discard any negotiated key
            material and abort without proceeding to the Next
            Protocol. Unrecognized warning codes MUST be treated as
            errors.
          </t>
          <t>
            This memo defines no warning codes.
          </t>
        </section>
        <section title="AEAD Algorithm Negotiation">
          <t>
            The AEAD Algorithm Negotiation record has a Record Type
            number of 4. Its body consists of a sequence of unsigned
            16-bit integers in network byte order, denoting Numeric
            Identifiers from the IANA <xref target="RFC5116">AEAD
            registry</xref>. The Critical Bit MAY be set.
          </t>
          <t>
            If the NTS Next Protocol Negotiation record offers
            Protocol ID 0 (for NTPv4), then this record MUST be
            included exactly once. Other protocols MAY require it as
            well.
          </t>
          <t>
            When included in a request, this record denotes which AEAD
            algorithms the client is willing to use to secure the Next
            Protocol, in decreasing preference order. When included in
            a response, this record denotes which algorithm the server
            chooses to use, or is empty if the server supports none of
            the algorithms offered. In requests, the list MUST
            include at least one algorithm. In responses, it MUST
            include at most one. Honoring the client's preference
            order is OPTIONAL: servers may select among any of the
            client's offered choices, even if they are able to support
            some other algorithm which the client prefers more.
          </t>
          <t>
            Server implementations of <xref
            target="nts-extension-fields-for-ntpv4">NTS extension
            fields for NTPv4</xref> MUST support <xref
            target="RFC5297">AEAD_AES_SIV_CMAC_256</xref> (Numeric
            Identifier 15). That is, if the client includes
            AEAD_AES_SIV_CMAC_256 in its AEAD Algorithm Negotiation
            record, and the server accepts Protocol ID 0 (NTPv4) in
            its NTS Next Protocol Negotiation record, then the
            server's AEAD Algorithm Negotiation record MUST NOT be
            empty.
          </t>
        </section>
        <section title="New Cookie for NTPv4" anchor="new-cookie-for-ntpv4">
          <t>
            The New Cookie for NTPv4 record has a Record Type number
            of 5. The contents of its body SHALL be
            implementation-defined and clients MUST NOT attempt to
            interpret them. See <xref
            target="suggested-format-for-nts-cookies"/> for a
            suggested construction.
          </t>
          <t>
            Clients MUST NOT send records of this type. Servers MUST
            send at least one record of this type, and SHOULD send
            eight of them, if they accept Protocol ID 0 (NTPv4) as a
            Next Protocol. The Critical Bit SHOULD NOT be set.
          </t>
        </section>
      </section>
      <section title="Key Extraction (generally)">
        <t>
          Following a successful run of the NTS-KE protocol, key
          material SHALL be extracted according to <xref
          target="RFC5705">RFC 5705</xref>. Inputs to the exporter
          function are to be constructed in a manner specific to the
          negotiated Next Protocol. However, all protocols which
          utilize NTS-KE MUST conform to the following two
          rules:
          <list>
            <t>
              The disambiguating label string MUST be
              &quot;EXPORTER-network-time-security/1&quot;.
            </t>
            <t>
              The per-association context value MUST be provided, and
              MUST begin with the two-octet Protocol ID which was
              negotiated as a Next Protocol.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="NTS Extension Fields for NTPv4" anchor="nts-extension-fields-for-ntpv4">
      <section title="Key Extraction (for NTPv4)">
      <t>
        Following a successful run of the NTS-KE protocol wherein
        Protocol ID 0 (NTPv4) is selected as a Next Protocol, two AEAD
        keys SHALL be extracted: a client-to-server (C2S) key and a
        server-to-client (S2C) key. These keys SHALL be computed
        according to <xref target="RFC5705">RFC 5705</xref>, using the
        following inputs.
        <list>
          <t>
            The disambiguating label string SHALL be
            &quot;EXPORTER-network-time-security/1&quot;.
          </t>
          <t>
            The per-association context value SHALL consist of the
            following five octets:
            <list>
              <t>
                The first two octets SHALL be zero (the Protocol ID
                for NTPv4).
              </t>
              <t>
                The next two octets SHALL be the Numeric Identifier of
                the negotiated AEAD Algorithm, in network byte order.
              </t>
              <t>
                The final octet SHALL be 0x00 for the C2S key and 0x01
                for the S2C key.
              </t>
            </list>
          </t>
        </list>
        Implementations wishing to derive additional keys for private
        or experimental use MUST NOT do so by extending the
        above-specified syntax for per-association context values.
        Instead, they SHOULD use their own disambiguating label
        string. Note that RFC 5705 provides that disambiguating label
        strings beginning with &quot;EXPERIMENTAL&quot; MAY be used
        without IANA registration.
      </t>
      </section>
      <section title="Packet structure overview">
        <t>
          In general, an NTS-protected NTPv4 packet consists of:
          <list>
            <t>
              The usual 48-octet NTP header, which is authenticated
              but not encrypted.
            </t>
            <t>
              Some extension fields which are authenticated but not encrypted.
            </t>
            <t>
              An extension field which contains AEAD output (i.e., an
              authentication tag and possible ciphertext). The
              corresponding plaintext, if non-empty, consists of some
              extension fields which benefit from both encryption and
              authentication.
            </t>
            <t>
              Possibly, some additional extension fields which are
              neither encrypted nor authenticated. These are discarded
              by the receiver.
            </t>
          </list>
        </t>
        <t>
          Always included among the authenticated or
          authenticated-and-encrypted extension fields are a cookie
          extension field and a unique-identifier extension field. The
          purpose of the cookie extension field is to enable the
          server to offload storage of session state onto the
          client. The purpose of the unique-identifier extension field
          is to protect the client from replay attacks.
        </t>
      </section>
      <section title="The Unique Identifier extension field">
        <t>
          The Unique Identifier extension field has a Field Type of
          [[TBD2]]. When the extension field is included in a client
          packet (mode 3), its body SHALL consist of a string of
          octets generated uniformly at random. The string MUST be at
          least 32 octets long.  When the extension field is included in a
          server packet (mode 4), its body SHALL contain the same
          octet string as was provided in the client packet to which
          the server is responding. Its use in modes other than
          client-server is not defined.
        </t>
        <t>
          The Unique Identifier extension field provides the client
          with a cryptographically strong means of detecting replayed
          packets. It MAY also be used standalone, without NTS, in
          which case it provides the client with a means of detecting
          spoofed packets from off-path attackers. Historically, NTP's
          origin timestamp field has played both these roles, but for
          cryptographic purposes this is suboptimal because it is only
          64 bits long and, depending on implementation details, most
          of those bits may be predictable. In contrast, the Unique
          Identifier extension field enables a degree of
          unpredictability and collision-resistance more consistent
          with cryptographic best practice.
        </t>
      </section>
      <section title="The NTS Cookie extension field" anchor="nts-cookie-extension-field">
        <t>
          The NTS Cookie extension field has a Field Type of
          [[TBD3]]. Its purpose is to carry information which enables
          the server to recompute keys and other session state without
          having to store any per-client state. The contents of its
          body SHALL be implementation-defined and clients MUST NOT
          attempt to interpret them. See <xref
          target="suggested-format-for-nts-cookies"/> for a
          suggested construction.  The NTS Cookie extension field
          MUST NOT be included in NTP packets whose mode is other than
          3 (client) or 4 (server).
        </t>
      </section>
      <section title="The NTS Cookie Placeholder extension field">
        <t>
          The NTS Cookie Placeholder extension field has a Field Type
          of [[TBD4]].  When this extension field is included in a
          client packet (mode 3), it communicates to the server that
          the client wishes it to send additional cookies in its
          response. This extension field MUST NOT be included in NTP
          packets whose mode is other than 3.
        </t>
        <t>
          Whenever an NTS Cookie Placeholder extension field is
          present, it MUST be accompanied by an NTS Cookie extension
          field, and the body length of the NTS Cookie Placeholder
          extension field MUST be the same as the body length of the
          NTS Cookie extension field. (This length requirement serves
          to ensure that the response will not be larger than the
          request, in order to improve timekeeping precision and
          prevent DDoS amplification). The contents of the NTS Cookie
          Placeholder extension field's body are undefined and, aside
          from checking its length, MUST be ignored by the server.
        </t>
      </section>

      <section title="The NTS Authenticator and Encrypted Extension Fields extension field">
        <t>
          The NTS Authenticator and Encrypted Extension Fields extension field is
          the central cryptographic element of an NTS-protected NTP
          packet. Its Field Type is [[TBD5]] and the format of its body
          SHALL be as follows:
          <list>
            <t>
              Nonce length: Two octets in network byte order, giving
              the length of the Nonce field and interpreted as an
              unsigned integer.
            </t>
            <t>
              Nonce: A nonce as required by the negotiated AEAD Algorithm.
            </t>
            <t>
              Ciphertext: The output of the negotiated AEAD
              Algorithm. The structure of this field is determined by
              the negotiated algorithm, but it typically contains an
              authentication tag in addition to the actual ciphertext.
            </t>
            <t>
              Padding: several octets of padding, with every octet set
              to the number of padding octets included, e.g.,
              &quot;01&quot;, &quot;02 02&quot;, or &quot;03 03
              03&quot;. Constraints on the number of padding octets
              included are enumerated below.
            </t>
          </list>
        </t>
        <t>
          The Ciphertext field SHALL be formed by providing the
          following inputs to the negotiated AEAD Algorithm:
          <list>
            <t>
              K: For packets sent from the client to the server, the
              C2S key SHALL be used. For packets sent from the server
              to the client, the S2C key SHALL be used.
            </t>
            <t>
              A: The associated data SHALL consist of the portion of
              the NTP packet beginning from the start of the NTP
              header and ending at the end of the last extension field
              which precedes the NTS Authenticator and Encrypted
              Extension Fields extension field.
            </t>
            <t>
              P: The plaintext SHALL consist of all (if any) NTP
              extension fields to be encrypted. The format of any such
              fields SHALL be in accordance with <xref
              target="RFC7822">RFC 7822</xref>, and if multiple
              extension fields are present they SHALL be joined by
              concatenation.
            </t>
            <t>
              N: The nonce SHALL be formed however required by the
              negotiated AEAD Algorithm.
            </t>
          </list>
        </t>
	<t>
	  The number of padding octets included SHALL conform to the
	  following constraints:
	  <list>
	    <t>
	      The number MUST be at least 1, so that the final octet
	      of the extension field always gives the padding length.
	    </t>
	    <t>
	      The number MUST NOT be greater than 255, since high
	      numbers are unrepresentable in a single octet
	    </t>
	    <t>
	      The number MUST result in an extension field length
	      which is legal per <xref target="RFC7822"/>. That is,
	      the number of padding octets must be chosen so that the
	      total length of the extension field (including the Field
	      Type and Length subfields) is a multiple of 4 greater
	      than or equal to 16, and greater than or equal to 28 if
	      the extension field is the last one in the packet.
	    </t>
	    <t>
	      For mode 3 (client) packets only, the number MUST be at
	      least MAX(MIN(N_MAX, 16) - N_len, 0) + 4, where `N_len`
	      represents the actual length of the nonce and N_MAX is,
	      per <xref target="RFC5116"/>, the maximum permitted
	      nonce length for the AEAD algorithm in use. This
	      constraint ensures that servers can always use an
	      adequately long nonce without causing the size of their
	      response packet to exceed the size of the request
	      packet. Servers SHOULD enforce this constraint by
	      dropping client packets that do not conform to it.
	      Clients MUST NOT enforce it since it is not binding on
	      mode 4 (server) packets to begin with.
	    </t>
	  </list>
	</t>
        <t>
          The NTS Authenticator and Encrypted Extension Fields
          extension field MUST NOT be included in NTP packets whose
          mode is other than 3 (client) or 4 (server).
        </t>
      </section>
    </section>
    <section title="Protocol details">
        <t>
          A client sending an NTS-protected request SHALL include the
          following extension fields as displayed in  <xref
          target="fig_NTSTimeSyncMessage"/>:
          <list>
            <t>
              Exactly one Unique Identifier extension field, which
              MUST be authenticated, MUST NOT be encrypted, and whose
              contents MUST NOT duplicate those of any previous
              request.
            </t>
            <t>
              Exactly one NTS Cookie extension field, which MUST be
              authenticated and MUST NOT be encrypted. The cookie MUST
              be one which the server previously provided the client;
              it may have been provided during the NTS-KE handshake or
              in response to a previous NTS-protected NTP request.  To
              protect client's privacy, the same cookie SHOULD NOT be
              included in multiple requests. If the client does not
              have any cookies that it has not already sent, it SHOULD
              re-run the NTS-KE protocol before continuing.
            </t>
            <t>
              Exactly one NTS Authenticator and Encrypted Extension
              Fields extension field, generated using an AEAD
              Algorithm and C2S key established through NTS-KE.
            </t>
          </list>
        </t>
        <t>
          The client MAY include one or more NTS Cookie Placeholder
          extension field, which MUST be authenticated and MAY be
          encrypted. The number of NTS Cookie Placeholder extension
          fields that the client includes SHOULD be such that if the
          client includes N placeholders and the server sends back N+1
          cookies, the number of unused cookies stored by the client
          will come to eight. When both the client and server adhere
          to all cookie-management guidance provided in this memo, the
          number of placeholder extension fields will equal the number
          of dropped packets since the last successful volley.
        </t>
        <t>
          The client MAY include additional (non-NTS-related)
          extension fields, which MAY appear prior to the NTS
          Authenticator and Encrypted Extension Fields extension
          fields (therefore authenticated but not encrypted), within
          it (therefore encrypted and authenticated), or after it
          (therefore neither encrypted nor authenticated). In general,
          however, the server MUST discard any unauthenticated
          extension fields and process the packet as though they were
          not present. Servers MAY implement exceptions to this
          requirement for particular extension fields if their
          specification explicitly provides for such.
        </t>
        <t>
          Upon receiving an NTS-protected request, the server SHALL
          (through some implementation-defined mechanism) use the
          cookie to recover the AEAD Algorithm, C2S key, and S2C key
          associated with the request, and then use the C2S key to
          authenticate the packet and decrypt the ciphertext.  If the
          cookie is valid and authentication and decryption succeed,
          then the server SHALL include the following extension fields
          in its response:
          <list>
            <t>
              Exactly one Unique Identifier extension field, which
              MUST be authenticated, MUST NOT be encrypted, and whose
              contents SHALL echo those provided by the client.
            </t>
            <t>
              Exactly one NTS Authenticator and Encrypted Extension
              Fields extension field, generated using the AEAD
              algorithm and S2C key recovered from the cookie provided
              by the client.
            </t>
            <t>
              One or more NTS Cookie extension fields, which MUST be
              encrypted and authenticated. The number of NTS Cookie
              extension fields included SHOULD be equal to, and MUST
              NOT exceed, one plus the number of valid NTS Cookie
              Placeholder extension fields included in the request.
            </t>
          </list>
        </t>
	<t>
	  We emphasize the contrast that NTS Cookie extension fields
	  MUST NOT be encrypted when sent from client to server, but
	  MUST be encrypted from sent from server to client. The
	  former is necessary in order for the server to be able to
	  recover the C2S and S2C keys, while the latter is
	  necessary to satisfy the unlinkability goals discussed in
	  <xref target="Unlinkability"/>. We emphasize also that
	  &quot; encrypted&quot; means encapsulated within the the NTS
	  Authenticator and Encrypted Extensions extension
	  field. While the body of a NTS Cookie extension field will
	  generally consist of some sort of AEAD output (regardless of
	  whether the recommendations of <xref
	  target="suggested-format-for-nts-cookies"/> are precisely
	  followed), this is not sufficient to make the extension
	  field &quot;encrypted&quot;.
	</t>
        <t>
          The server MAY include additional (non-NTS-related)
          extension fields, which MAY appear prior to the NTS
          Authenticator and Encrypted Extension Fields extension field
          (therefore authenticated but not encrypted), within it
          (therefore encrypted and authenticated), or after it
          (therefore neither encrypted nor authenticated). In general,
          however, the client MUST discard any unauthenticated
          extension fields and process the packet as though they were
          not present. Clients MAY implement exceptions to this
          requirement for particular extension fields if their
          specification explicitly provides for such.
        </t>
        <t>
          If the server is unable to validate the cookie or
          authenticate the request, it SHOULD respond with a
          Kiss-o'-Death packet (see <xref target="RFC5905">RFC 5905,
          Section 7.4)</xref>) with kiss code &quot;NTSN&quot;
          (meaning &quot;NTS NAK&quot;). Such a response MUST include
          exactly one Unique Identifier extension field whose contents
          SHALL echo those provided by the client.  It MUST NOT
          include any NTS Cookie or NTS Authenticator and Encrypted
          Extension Fields extension fields.
        </t>
        <t>
          Upon receiving an NTS-protected response, the client MUST
          verify that the Unique Identifier matches that of an
          outstanding request, and that the packet is authentic under
          the S2C key associated with that request. If either of these
          checks fails, the packet MUST be discarded without further
          processing.
        </t>
        <t>
          Upon receiving an NTS NAK, the client MUST verify that the
          Unique Identifier matches that of an outstanding request. If
          this check fails, the packet MUST be discarded without
          further processing. If this check passes, the client SHOULD
          wait until the next poll for a valid NTS-protected response
          and if none is received, discard all cookies and AEAD keys
          associated with the server which sent the NAK and initiate a
          fresh NTS-KE handshake.
        </t>
        <figure anchor="fig_NTSTimeSyncMessage" title="NTS Time Synchronization Message">
          <artwork><![CDATA[                +---------------------------------------+
                | - verify time request message         |
                | - generate time response message      |
                |   - included NTPv4 extension fields   |
                |      o Unique Identifier EF           |
                |      o NTS Authentication and         |
                |        Encrypted Extension Fields EF  |
                |        - NTS Cookie EF                |
                |        - <NTS Cookie EF>              |
                | - transmit time request packet        |
                +-----------------+---------------------+
                                  |
                                  |
Server -------- --+---------------+-----+----------------------->
                  ^                      \
                 /                        \
  time request  /                          \   time response
  (mode 3)     /                            \  (mode 4)
              /                              \
             /                                V
Client -----+---------------------------------+---------------->
            |                                 |
            |                                 |
            |                                 |
+-----------+----------------------+   +------+-----------------+
|- generate time request message   |   |- verify time response  |
| - include NTPv4 Extension fields |   |  message               |
|    o Unique Identifier EF        |   |- extract cookie(s)     |
|    o NTS Cookie EF               |   |- time synchronization  |
|    o <NTS Cookie Placeholder EF> |   |  processing            |
|                                  |   +------------------------+
|- generate AEAD tag of NTP message|
|- add NTS Authentication and      |
|  Encrypted Extension Fields EF   |
|- transmit time request packet    |
+----------------------------------+   ]]></artwork>
      </figure>
      </section>
    <section title="Suggested format for NTS cookies" anchor="suggested-format-for-nts-cookies">
      <t>
	This section is non-normative. It gives a suggested way for
	servers to construct NTS cookies. All normative requirements
	are stated in <xref target="new-cookie-for-ntpv4"/> and <xref
	target="nts-cookie-extension-field"/>.
      </t>
      <t>
        The role of cookies in NTS is closely analogous to that of
        session cookies in TLS. Accordingly, the thematic resemblance
        of this section to <xref target="RFC5077">RFC 5077</xref> is
        deliberate, and the reader should likewise take heed of its
        security considerations.
      </t>
      <t>
        Servers should select an AEAD algorithm which they will use to
        encrypt and authenticate cookies. The chosen algorithm should
        be one such as <xref
        target="RFC5297">AEAD_AES_SIV_CMAC_256</xref> which resists
        accidental nonce reuse, and it need not be the same as the
        one that was negotiated with the client. Servers should
        randomly generate and store a master AEAD key `K`. Servers
        should additionally choose a non-secret, unique value `I` as
        key-identifier for `K`.
      </t>
      <t>
        Servers should periodically (e.g., once daily) generate a new
        pair (I,K) and immediately switch to using these values for
        all newly-generated cookies. Immediately following each such
        key rotation, servers should securely erase any keys generated
        two or more rotation periods prior. Servers should continue to
        accept any cookie generated using keys that they have not yet
        erased, even if those keys are no longer current. Erasing old
        keys provides for forward secrecy, limiting the scope of what
        old information can be stolen if a master key is somehow
        compromised. Holding on to a limited number of old keys allows
        clients to seamlessly transition from one generation to the
        next without having to perform a new NTS-KE handshake.
      </t>
      <t>
        The need to keep keys synchronized across load-balanced
        clusters can make automatic key rotation challenging. However,
        the task can be accomplished without the need for central
        key-management infrastructure by using a ratchet, i.e., making
        each new key a deterministic, cryptographically pseudo-random
        function of its predecessor. A recommended concrete
        implementation of this approach is to use <xref
        target="RFC5869">HKDF</xref> to derive new keys, using the
        key's predecessor as Input Keying Material and its key identifier
        as a salt.
      </t>
      <t>
        To form a cookie, servers should first form a plaintext `P`
        consisting of the following fields:
        <list>
          <t>The AEAD algorithm negotiated during NTS-KE</t>
          <t>The S2C key</t>
          <t>The C2S key</t>
        </list>
      </t>
      <t>
        Servers should then generate a nonce `N` uniformly at random,
        and form AEAD output `C` by encrypting `P` under key `K` with
        nonce `N` and no associated data.
      </t>
      <t>
        The cookie should consist of the tuple `(I,N,C)`.
      </t>
      <t>
        To verify and decrypt a cookie provided by the client, first
        parse it into its components `I`, `N`, and `C`. Use `I` to
        look up its decryption key `K`. If the key whose identifier is
        `I` has been erased or never existed, decryption fails; reply
        with an NTS NAK. Otherwise, attempt to decrypt and verify
        ciphertext `C` using key `K` and nonce `N` with no associated
        data. If decryption or verification fails, reply with an NTS
        NAK. Otherwise, parse out the contents of the resulting
        plaintext `P` to obtain the negotiated AEAD algorithm, S2C key,
        and C2S key.
      </t>
    </section>

      <section title="IANA Considerations" anchor="iana-considerations">
      <t>
        IANA is requested to allocate two entries, identical except
        for the Transport Protocol, in the Service Name and Transport
        Protocol Port Number Registry as follows:
        <list>
          <t>Service Name: nts</t>
          <t>Transport Protocol: tcp, udp</t>
          <t>Assignee: IESG &lt;iesg@ietf.org&gt;</t>
          <t>Contact: IETF Chair &lt;chair@ietf.org&gt;</t>
          <t>Description: Network Time Security</t>
          <t>Reference: [[this memo]]</t>
          <t>Port Number: [[TBD1]], selected by IANA from the user port range</t>
        </list>
      </t>
      <t>
        IANA is requested to allocate the following entry in the
        Application-Layer Protocol Negotation (ALPN) Protocol IDs
        registry:
        <list>
          <t>Protocol: Network Time Security Key Establishment, version 1</t>
          <t>
            Identification
            Sequence:<vspace/>&nbsp;&nbsp;0x6E&nbsp;0x74&nbsp;0x73&nbsp;0x6B&nbsp;0x65&nbsp;0x2F&nbsp;0x31&nbsp;("ntske/1")
          </t>
          <t>Reference: [[this memo]]</t>
        </list>
        <vspace/>
      </t>
      <t>
        IANA is requested to allocate the following entry in the TLS
        Exporter Label Registry:
      </t>
      <texttable>
        <ttcol>Value</ttcol>
        <ttcol>DTLS-OK</ttcol>
        <ttcol>Reference</ttcol>
        <ttcol>Note</ttcol>
        <c>EXPORTER-network-time-security/1</c>
        <c>Y</c>
        <c>[[this memo]]</c>
        <c/>
      </texttable>
      <t>
        IANA is requested to allocate the following entry in the registry
        of NTP Kiss-o'-Death codes:
      </t>
      <texttable>
        <ttcol>Code</ttcol><ttcol>Meaning</ttcol>
        <c>NTSN</c><c>NTS NAK</c>
      </texttable>
      <t>
        IANA is requested to allocate the following entries in the
        NTP Extensions Field Types registry:
      </t>
      <texttable>
        <ttcol>Field Type</ttcol>
        <ttcol>Meaning</ttcol>
        <ttcol>Reference</ttcol>
        <c>[[TBD2]]</c><c>Unique Identifier</c><c>[[this memo]]</c>
        <c>[[TBD3]]</c><c>NTS Cookie</c><c>[[this memo]]</c>
        <c>[[TBD4]]</c><c>NTS Cookie Placeholder</c><c>[[this memo]]</c>
        <c>[[TBD5]]</c><c>NTS Authenticator and Encrypted Extension Fields</c><c>[[this memo]]</c>
      </texttable>
      <t>
        IANA is requested to create a new registry entitled
        &quot;Network Time Security Key Establishment Record Types&quot;.
        Entries SHALL have the following fields:
        <list>
          <t>
            Type Number (REQUIRED): An integer in the range 0&ndash;32767
            inclusive.
          </t>
          <t>
            Description (REQUIRED): A short text description of the
            purpose of the field.
          </t>
          <t>
            Set Critical Bit (REQUIRED): One of &quot;MUST&quot;,
            &quot;SHOULD&quot;, &quot;MAY&quot;,  &quot;SHOULD NOT&quot;,
            or &quot;MUST NOT&quot;.
          </t>
          <t>
            Reference (REQUIRED): A reference to a document specifying
            the semantics of the record.
          </t>
        </list>
      </t>
      <t>
        The policy for allocation of new entries in this registry SHALL vary
        by the Type Number, as follows:
        <list>
          <t>0&ndash;1023: IETF Review</t>
          <t>1024&ndash;16383: Specification Required</t>
          <t>16384&ndash;32767: Private and Experimental Use</t>
        </list>
      </t>
      <t>
        Applications for new entries SHALL specify the contents of the
        Description, Set Critical Bit and Reference fields and which
        of the above ranges the Type Number should be allocated
        from. Applicants MAY request a specific Type Number, and such
        requests MAY be granted at the registrar's discretion.
      </t>
      <t>
        The initial contents of this registry SHALL be as follows:
      </t>
      <texttable>
        <ttcol>Field Number</ttcol>
        <ttcol>Description</ttcol>
        <ttcol>Critical</ttcol>
        <ttcol>Reference</ttcol>

        <c>0</c>
        <c>End of message</c>
        <c>MUST</c>
        <c>[[this memo]]</c>

        <c>1</c>
        <c>NTS next protocol negotiation</c>
        <c>MUST</c>
        <c>[[this memo]]</c>

        <c>2</c>
        <c>Error</c>
        <c>MUST</c>
        <c>[[this memo]]</c>

        <c>3</c>
        <c>Warning</c>
        <c>MUST</c>
        <c>[[this memo]]</c>

        <c>4</c>
        <c>AEAD algorithm negotiation</c>
        <c>MAY</c>
        <c>[[this memo]]</c>

        <c>5</c>
        <c>New cookie for NTPv4</c>
        <c>SHOULD NOT</c>
        <c>[[this memo]]</c>

        <c>16384&ndash;32767</c>
        <c>Reserved for Private &amp; Experimental Use</c>
        <c>MAY</c>
        <c>[[this memo]]</c>
      </texttable>
      <t>
        IANA is requested to create a new registry entitled
        &quot;Network Time Security Next Protocols&quot;.
        Entries SHALL have the following fields:
        <list>
          <t>
            Protocol ID (REQUIRED): An integer in the range 0-65535
            inclusive, functioning as an identifier.
          </t>
          <t>
            Protocol Name (REQUIRED): A short text string naming the
            protocol being identified.
          </t>
          <t>
            Reference (RECOMMENDED): A reference to a relevant
            specification document. If no relevant document exists, a
            point-of-contact for questions regarding the entry SHOULD
            be listed here in lieu.
          </t>
        </list>
      </t>
      <t>
        Applications for new entries in this registry SHALL specify
        all desired fields, and SHALL be granted upon approval by a
        Designated Expert. Protocol IDs 32768-65535 SHALL be reserved
        for Private or Experimental Use, and SHALL NOT be
        registered.
      </t>
      <t>
        The initial contents of this registry SHALL be as follows:
      </t>
      <texttable>
        <ttcol>Protocol ID</ttcol>
        <ttcol>Human-Readable Name</ttcol>
        <ttcol>Reference</ttcol>

        <c>0</c>
        <c>Network Time Protocol version 4 (NTPv4)</c>
        <c>[[this memo]]</c>

        <c>32768-65535</c>
        <c>Reserved for Private or Experimental Use</c>
        <c>Reserved by [[this memo]]</c>
      </texttable>
      <t>
        IANA is requested to create two new registries entitled
        &quot;Network Time Security Error Codes&quot; and
        &quot;Network Time Security Warning Codes&quot;. Entries in
        each SHALL have the following fields:
        <list>
          <t>Number (REQUIRED): An integer in the range 0-65535 inclusive.</t>
          <t>Description (REQUIRED): A short text description of the condition.</t>
          <t>Reference (REQUIRED): A reference to a relevant specification document.</t>
        </list>
        The policy for allocation of new entries in these registries
        SHALL vary by their Number, as follows:
        <list>
          <t>0&ndash;1023: IETF Review</t>
          <t>1024&ndash;32767: Specification Required</t>
          <t>32768&ndash;65535: Private and Experimental Use</t>
        </list>
      </t>
      <t>
        The initial contents of the Network Time Security Error Codes Registry SHALL be as follows:
      </t>
      <texttable>
        <ttcol>Number</ttcol><ttcol>Description</ttcol><ttcol>Reference</ttcol>
        <c>0</c><c>Unrecognized Critical Extension</c><c>[[this memo]]</c>
        <c>1</c><c>Bad Request</c><c>[[this memo]]</c>
      </texttable>
      <t>
        The Network Time Security Warning Codes Registry SHALL initially be empty.
      </t>
    </section>
    <section title="Implementation Status">
      <t>This section records the status of known implementations of the
      protocol defined by this specification at the time of posting of this
      Internet-Draft, and is based on a proposal described in RFC 7942. The
      description of implementations in this section is intended to assist the
      IETF in its decision processes in progressing drafts to RFCs. Please
      note that the listing of any individual implementation here does not
      imply endorsement by the IETF. Furthermore, no effort has been spent to
      verify the information presented here that was supplied by IETF
      contributors. This is not intended as, and must not be construed to be,
      a catalog of available implementations or their features. Readers are
      advised to note that other implementations may exist.</t>

      <t>According to RFC 7942, "this will allow reviewers and working groups
      to assign due consideration to documents that have the benefit of
      running code, which may serve as evidence of valuable experimentation
      and feedback that have made the implemented protocols more mature. It is
      up to the individual working groups to use this information as they see
      fit".</t>

      <section title="Implementation PoC 1">
        <t>Organization: Ostfalia University of Applied Science</t>

        <t>Implementor: Martin Langer</t>

        <t>Maturity: Proof-of-Concept Prototype</t>

        <t>This implementation was used to verify consistency and to ensure
        completeness of this specification. It also demonstrate
        interoperability with NTP's client-server mode messages.</t>

        <section title="Coverage">
          <t>This implementation covers the complete specification.</t>
        </section>

        <section title="Licensing">
          <t>The code is released under a Apache License 2.0 license. </t>

          <t>The source code is available at:
          https://gitlab.com/MLanger/nts/</t>
        </section>

        <section title="Contact Information">
          <t>Contact Martin Langer: mart.langer@ostfalia.de</t>
        </section>

        <section title="Last Update">
          <t>The implementation was updated 3rd May 2018.</t>
        </section>
      </section>

      <section title="Implementation PoC 2">
        <t>Organization: tbd</t>

        <t>Implementor: Daniel Fox Franke </t>

        <t>Maturity: Proof-of-Concept Prototype</t>

        <t>This implementation was used to verify consistency and to ensure
        completeness of this specification. </t>

        <section title="Coverage">
          <t>This implementation provides the client and the server for the
          initial TLS handshake and NTS key exchange. It provides the the
          client part of the NTS protected NTP messages. </t>
        </section>

        <section title="Licensing">
          <t>Public domain.</t>

          <t>The source code is available at:
          https://github.com/dfoxfranke/nts-hackathon</t>
        </section>

        <section title="Contact Information">
          <t>Contact Daniel Fox Franke: dfoxfranke@gmail.com</t>
        </section>

        <section title="Last Update">
          <t>The implementation was updated 16th March 2018.</t>
        </section>
      </section>

      <section title="Interoperability ">
        <t>The Interoperability tests distinguished between NTS key
        exchange and NTS time exchange messages. For the
        NTS key exchange, interoperability  between
        the two implementations  has been verified successfully.
        Interoperability of NTS time exchange messages has been verified
        successfully for the case that PoC 1 represents the server and
        PoC 2 the client.</t>

        <t>These tests successfully
        demonstrate that there are at least two running implementations
        of this draft which are able to interoperate.
        </t>
      </section>
    </section>
    <section title="Security considerations">
      <section title="Avoiding DDoS amplification">
        <t>
          Certain non-standard and/or deprecated features of the Network
          Time Protocol enable clients to send a request to a server
          which causes the server to send a response much larger than
          the request. Servers which enable these features can be abused
          in order to amplify traffic volume in distributed
          denial-of-service (DDoS) attacks by sending them a request
          with a spoofed source IP. In recent years, attacks of this nature
          have become an endemic nuisance.
        </t>
        <t>
          NTS is designed to avoid contributing any further to this
          problem by ensuring that NTS-related extension fields included in
          server responses will be the same size as the NTS-related
          extension fields sent by the client. In particular, this is why
          the client is required to send a separate and appropriately
          padded-out NTS Cookie Placeholder extension field for every cookie
          it wants to get back, rather than being permitted simply to
          specify a desired quantity.
        </t>
	<t>
	  Due to the <xref target="RFC7822"/> requirement that extensions
	  be padded and aligned to four-octet boundaries, response size
	  may still in some cases exceed request size by up to three
	  octets. This is sufficiently inconsequential that we have
	  declined to address it.
	</t>
      </section>
      <section title="Initial verification of server certificates">
	<t>
	  NTS's security goals are undermined if the client fails to
	  verify that the X.509 certificate chain presented by the
	  server is valid and rooted in a trusted certificate
	  authority. <xref target="RFC5280"/> and <xref
	  target="RFC6125"/> specify how such verification is to be
	  performed in general. However, the expectation that the
	  client does not yet have a correctly-set system clock at the
	  time of certificate verification presents difficulties with
	  verifying that the certificate is within its validity
	  period, i.e., that the current time lies between the times
	  specified in the certificate's notBefore and notAfter
	  fields, and it may be operationally necessary in some cases
	  for a client to accept a certificate which appears to be
	  expired or not yet valid. While there is no perfect solution
	  to this problem, there are several mitigations the client
	  can implement to make it more difficult for an adversary to
	  successfully present an expired certificate:
	  <list>
	    <t>
	      Check whether the system time is in fact unreliable. If
	      the system clock has previously been synchronized since
	      last boot, then on operating systems which implement a
	      kernel-based phase-locked-loop API, a call to
	      ntp_gettime() should show a maximum error less than
	      NTP_PHASE_MAX. In this case, the clock SHOULD be
	      considered reliable and certificates can be strictly
	      validated.
	    </t>
	    <t>
	      Allow the system administrator to specify that
	      certificates should *always* be strictly validated. Such
	      a configuration is appropriate on systems which have a
	      battery-backed clock and which can reasonably prompt the
	      user to manually set an approximately-correct time if it
	      appears to be needed.
	    </t>
	    <t>
	      Once the clock has been synchronized, periodically write
	      the current system time to persistent storage. Do not accept
	      any certificate whose notAfter field is earlier than the last
	      recorded time.
	    </t>
	    <t>
	      Do not process time packets from servers if the time
	      computed from them falls outside the validity period of
	      the server's certificate.
	    </t>
	    <t>
	      Use multiple time sources. The ability to pass off an
	      expired certificate is only useful to an adversary who
	      has compromised the corresponding private key. If the
	      adversary has compromised only a minority of servers,
	      NTP's selection algorithm (<xref target="RFC5905"/>
	      section 11.2.1) will protect the client from accepting
	      bad time from the adversary-controlled servers.
	    </t>
	  </list>
	</t>
      </section>
      <section title="Usage of NTP pools">
        <t>
	  Additional standardization work and infrastructure
	  development is necessary before NTS can be used with public
	  NTP server pools. First, a scheme will need to be specified
	  for determining what constitutes an acceptable certificate
	  for a pool server, such as establishing a value required to
	  be contained in its Extended Key Usage attribute, and how to
	  determine, given the DNS name of a pool, what Subject
	  Alternative Name to expect in the certificates of its
	  members. Implementing any such specification will
	  necessitate infrastructure work: pool organizers will need
	  to act as certificate authorities, regularly monitor the
	  behavior of servers to which certificates have been issued,
	  and promptly revoke the certificate of any server found to
	  be serving incorrect time.
	</t>
      </section>
      <section anchor="DelayAttack" title="Delay attacks">
        <t>
	  In a packet delay attack, an adversary with the ability to
	  act as a man-in-the-middle delays time synchronization
	  packets between client and server asymmetrically <xref
	  target="RFC7384"/>. Since NTP's formula for computing time
	  offset relies on the assumption that network latency is
	  roughly symmetrical, this leads to the client to compute an
	  inaccurate value <xref target="Mizrahi"/>. The delay attack
	  does not reorder or modify the content of the exchanged
	  synchronization packets. Therefore, cryptographic means do
	  not provide a feasible way to mitigate this attack. However,
	  the maximum error that an adversary can introduce is bounded
	  by half of the round trip delay.
	</t>
	<t>
	  <xref target="RFC5905"/> specifies a parameter called
	  MAXDIST which denotes the maximum round-trip latency
	  (including not only the immediate round trip between client
	  and server but the whole distance back to the reference
	  clock as reported in the Root Delay field) that a client
	  will tolerate before concluding that the server is
	  unsuitable for synchronization. The standard value for
	  MAXDIST is one second, although some implementations use
	  larger values. Whatever value a client chooses, the maximum
	  error which can be introduced by a delay attack is
	  MAXDIST/2.
	</t>
	<t>
	  Usage of multiple time sources, or multiple network paths to
	  a given time source <xref target="Shpiner"/>, may also serve
	  to mitigate delay attacks if the adversary is in control of
	  only some of the paths.
	</t>
      </section>
      <section title="Random number generation">
        <t>
	  At various points in NTS, the generation of
	  cryptographically secure random numbers is required.
    Whenever this draft specifies the use of random numbers,
    then cryptographically secure random number generation MUST
    be used. See <xref target="RFC4086"/> for guidelines concerning
    this topic.
	</t>
      </section>
    </section>

    <section title="Privacy Considerations">
      <section title="Unlinkability" anchor="Unlinkability">
        <t>Unlinkability prevents a device from being tracked when it changes
        network addresses (e.g. because said device moved between different
        networks). In other words, unlinkability thwarts an attacker that
        seeks to link a new network address used by a device with a network
        address that it was formerly using, because of recognizable data that
        the device persistently sends as part of an NTS-secured NTP
        association. This is the justification for continually supplying the
        client with fresh cookies, so that a cookie never represents
        recognizable data in the sense outlined above. </t>

        <t>NTS's unlinkability objective is merely to not leak any additional
        data that could be used to link a device's network address. NTS does
        not rectify legacy linkability issues that are already present in NTP.
        Thus, a client that requires unlinkability must also minimize
        information transmitted in a client query (mode 3) packet as described
        in the draft <xref target="I-D.ietf-ntp-data-minimization"/>.
        </t>

        <t>The unlinkability objective only holds for time synchronization
        traffic, as opposed to key exchange traffic. This implies that it
        cannot be guaranteed for devices that function not only as time
        clients, but also as time servers (because the latter can be
        externally triggered to send authentication data). </t>

        <t>It should also be noted that it could be possible to link devices
        that operate as time servers from their time synchronization traffic,
        using information exposed in (mode 4) server response packets (e.g.
        reference ID, reference time, stratum, poll).&nbsp; Also, devices that
        respond to NTP control queries could be linked using the information
        revealed by control queries. </t>
      </section>
      <section title="Confidentiality">
	<t>
	  NTS does not protect the confidentiality of information in
	  NTP's header fields. When clients implement <xref
	  target="I-D.ietf-ntp-data-minimization"/>, client packet
	  headers do not contain any information which the client
	  could conceivably wish to keep secret: one field is random,
	  and all others are fixed. Information in server packet
	  headers is likewise public: the origin timestamp is copied
	  from the client's (random) transmit timestamp, and all other
	  fields are set the same regardless of the identity of the
	  client making the request.
	</t>
	<t>
	  Future extension fields could hypothetically contain
	  sensitive information, in which case NTS provides a
	  mechanism for encrypting them.
	</t>
      </section>


    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The authors would like to thank Richard Barnes, Steven
      Bellovin, Scott Fluhrer, Sharon Goldberg, Russ Housley, Martin
      Langer, Miroslav Lichvar, Aanchal Malhotra, Dave Mills, Danny
      Mayer, Karen O'Donoghue, Eric K. Rescorla, Stephen Roettger,
      Kurt Roeckx, Kyle Rose, Rich Salz, Brian Sniffen, Susan Sons,
      Douglas Stebila, Harlan Stenn, Martin Thomson, and Richard Welty
      for contributions to this document and comments on the design of
      NTS.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.5116'?>
      <?rfc include='reference.RFC.5297'?>
      <?rfc include='reference.RFC.5705'?>
      <?rfc include='reference.RFC.5746'?>
      <?rfc include='reference.RFC.5905'?>
      <?rfc include='reference.RFC.6125'?>
      <?rfc include='reference.RFC.7465'?>
      <?rfc include='reference.RFC.7507'?>
      <?rfc include='reference.RFC.7627'?>
      <?rfc include='reference.RFC.7301'?>
      <?rfc include='reference.RFC.7822'?>
    </references>

    <references title="Informative References">
      <?rfc include='reference.I-D.draft-ietf-ntp-data-minimization-00'?>
      <?rfc include='reference.RFC.4086'?>
      <?rfc include='reference.RFC.5077'?>
      <?rfc include="reference.RFC.5280'?>
      <?rfc include='reference.RFC.7384'?>
      <?rfc include='reference.RFC.5869'?>
      <reference anchor="Mizrahi" target="">
        <front>
          <title>A game theoretic analysis of delay attacks against time
          synchronization protocols</title>

          <author fullname="Tal Mizrahi" initials="T" surname="Mizrahi">
            <organization abbrev=""/>
          </author>

          <date day="" month="September" year="2012"/>
        </front>

        <seriesInfo name="in Proceedings of"
                    value="Precision Clock Synchronization for Measurement Control and Communication, ISPCS 2012, pp. 1-6"/>
      </reference>

      <reference anchor="Shpiner">
        <front>
          <title>Multi-path Time Protocols</title>

          <author fullname="Alexander Shpiner, Yoram Revah, and Tal Mizrahi">
            <organization/>
          </author>

          <date month="September" year="2013"/>
        </front>

        <seriesInfo name="in Proceedings of"
                    value="IEEE International Symposium on Precision Clock Synchronization for Measurement, Control and Communication (ISPCS)"/>
      </reference>
    </references>

    <section title="Terms and Abbreviations">
      <t>
	<list style="hanging">
	  <t hangText="AEAD">
	    Authenticated Encryption with Associated Data <xref target="RFC5116"/>
	  </t>
	  <t hangText="DDoS">
	    Distributed Denial of Service
	  </t>
      <t hangText="NTP ">
	    Network Time Protocol <xref target="RFC5905"/>
	  </t>
      <t hangText="NTS ">
	    Network Time Security
	  </t>
      <t hangText="TLS ">
	    Transport Layer Security
	  </t>
	</list>
      </t>
    </section>
  </back>
</rfc>
