<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-ietf-ntp-using-nts-for-ntp-25"
     ipr="trust200902" submissionType="IETF">
  <front>
    <title abbrev="NTS4NTP">Network Time Security for the Network Time
    Protocol</title>

    <author fullname="Daniel Fox Franke" initials="D." surname="Franke">
      <organization abbrev="Akamai">Akamai Technologies</organization>
      <address>
        <postal>
          <street>145 Broadway</street>
          <city>Cambridge</city>
          <region>MA</region>
          <code>02142</code>
          <country>United States</country>
        </postal>
        <email>dafranke@akamai.com</email>
      </address>
    </author>

    <author fullname="Dieter Sibold" initials="D." surname="Sibold">
      <organization abbrev="PTB">Physikalisch-Technische
      Bundesanstalt</organization>

      <address>
        <postal>
          <street>Bundesallee 100</street>

          <city>Braunschweig</city>

          <code>D-38116</code>

          <region/>

          <country>Germany</country>
        </postal>

        <phone>+49-(0)531-592-8420</phone>

        <facsimile>+49-531-592-698420</facsimile>

        <email>dieter.sibold@ptb.de</email>
      </address>
    </author>

    <author fullname="Kristof Teichel" initials="K." surname="Teichel">
      <organization abbrev="PTB">Physikalisch-Technische
      Bundesanstalt</organization>

      <address>
        <postal>
          <street>Bundesallee 100</street>

          <city>Braunschweig</city>

          <region/>

          <code>D-38116</code>

          <country>Germany</country>
        </postal>

        <phone>+49-(0)531-592-4471</phone>

        <facsimile/>

        <email>kristof.teichel@ptb.de</email>

        <uri/>
      </address>
    </author>

    <author fullname="Marcus Dansarie" initials="M." surname="Dansarie">
      <address>
        <postal>
          <street />
          <city />
          <region />
          <code />
          <country>Sweden</country>
        </postal>
        <email>marcus@dansarie.se</email>
        <uri>https://orcid.org/0000-0001-9246-0263</uri>
      </address>
    </author>

     <author fullname="Ragnar Sundblad" initials="R." surname="Sundblad">
      <organization>Netnod</organization>
      <address>
        <postal>
          <street />
          <city />
          <region />
          <code />
          <country>Sweden</country>
        </postal>
        <email>ragge@netnod.se</email>
      </address>
    </author>

    <date day="19" month="March" year="2020"/>

    <area>Internet Area</area>

    <workgroup>NTP Working Group</workgroup>

    <keyword>Integrity</keyword>

    <keyword>Authentication</keyword>

    <keyword>NTP</keyword>

    <keyword>Security</keyword>

    <abstract>
      <t>
        This memo specifies Network Time Security (NTS), a mechanism
        for using Transport Layer Security (TLS) and Authenticated
        Encryption with Associated Data (AEAD) to provide
        cryptographic security for the client-server mode of the
        Network Time Protocol (NTP).
      </t>
      <t>
        NTS is structured as a suite of two loosely coupled sub-protocols. 
        The first (NTS-KE) handles initial authentication and key 
        establishment over TLS. The second handles encryption and 
        authentication during NTP time synchronization via extension fields in the 
        NTP packets, and holds all required state only on the 
        client via opaque cookies.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
	This memo specifies Network Time Security (NTS), a
	cryptographic security mechanism for network time
	synchronization. A complete specification is provided for
	application of NTS to the client-server mode of the
        <xref target="RFC5905">Network Time Protocol (NTP)</xref>.
      </t>

      <section title="Objectives">
	<t>
	  The objectives of NTS are as follows:

	  <list style="symbols">
	    <t>
        Identity: Through the use of a X.509 public key infrastructure,
        implementations can cryptographically establish the identity of
        the parties they are communicating with.
	    </t>
	    <t>
	      Authentication: Implementations can cryptographically
	      verify that any time synchronization packets are
	      authentic, i.e., that they were produced by an
	      identified party and have not been modified in transit.
	    </t>
	    <t>
	      Confidentiality: Although basic time synchronization
	      data is considered non-confidential and sent in the
	      clear, NTS includes support for encrypting NTP extension
	      fields.
	    </t>
	    <t>
	      Replay prevention: Client implementations can detect when
	      a received time synchronization packet is a replay of
	      a previous packet.
	    </t>
	    <t>
	      Request-response consistency: Client implementations can
	      verify that a time synchronization packet received from
	      a server was sent in response to a particular request from
	      the client.
	    </t>
	    <t>
	      Unlinkability: For mobile clients, NTS will not leak any
	      information additional to NTP which would permit a
	      passive adversary to determine that two packets sent
	      over different networks came from the same client.
	    </t>
	    <t>
              Non-amplification: Implementations (especially server
              implementations) can avoid acting as distributed
              denial-of-service (DDoS) amplifiers by never responding to a
              request with a packet larger than the request packet.
	    </t>
	    <t>
	      Scalability: Server implementations can serve large
	      numbers of clients without having to retain any
	      client-specific state.
	    </t>
	    <t>
	      Performance: NTS must not significantly degrade the
	      quality of the time transfer. The encryption and
	      authentication used when actually transferring time
	      should be lightweight (see <xref target="RFC7384">RFC
	      7384, Section 5.7</xref>).
	    </t>
	  </list>
	</t>
      </section>

      <section title="Protocol Overview" anchor="sec-protocol-overview">
        <t>
          The Network Time Protocol includes many different operating modes to
          support various network topologies (see <xref target="RFC5905">RFC 5905,
          Section 3</xref>). In addition to its best-known and
          most-widely-used client-server mode, it also includes modes for
          synchronization between symmetric peers, a control mode for server
          monitoring and administration, and a broadcast mode. These various
          modes have differing and partly contradictory requirements for
          security and performance. Symmetric and control modes demand mutual
          authentication and mutual replay protection. Additionally, for certain
          message types control mode may require confidentiality as well as
          authentication. Client-server mode places more stringent requirements
          on resource utilization than other modes, because servers may have
          vast number of clients and be unable to afford to maintain per-client
          state. However, client-server mode also has more relaxed security
          needs, because only the client requires replay protection: it is
          harmless for stateless servers to process replayed packets. The
          security demands of symmetric and control modes, on the other hand,
          are in conflict with the resource-utilization demands of client-server
          mode: any scheme which provides replay protection inherently involves
          maintaining some state to keep track of what messages have already
          been seen.
        </t>

        <t>
          This memo specifies NTS exclusively for the client-server mode of NTP.
          To this end, NTS is structured as a suite of two protocols:

          <list>
            <t>
              The "NTS Extensions for NTPv4" define a collection of NTP
              extension fields for cryptographically securing NTPv4 using
              previously-established key material. They are suitable for
              securing client-server mode because the server can implement them
              without retaining per-client state. All state is kept by the
              client and provided to the server in the form of an encrypted
              cookie supplied with each request. On the other hand, the NTS
              Extension Fields are suitable *only* for client-server mode
              because only the client, and not the server, is protected from
              replay.
            </t>

            <t>
              The &quot;NTS Key Establishment&quot; protocol (NTS-KE) is a
              mechanism for establishing key material for use with the NTS
              Extension Fields for NTPv4. It uses TLS to exchange keys, provide
              the client with an initial supply of cookies, and negotiate some
              additional protocol options. After this exchange, the TLS channel
              is closed with no per-client state remaining on the server side.
            </t>
          </list>
        </t>

        <t>
          The typical protocol flow is as follows: The client connects to an
          NTS-KE server on the NTS TCP port and the two parties perform a TLS
          handshake. Via the TLS channel, the parties negotiate some additional
          protocol parameters and the server sends the client a supply of
          cookies along with an address of an NTP server
          for which the cookies are valid. The parties use
          <xref target="RFC5705">TLS key export</xref> to extract key material
          which will be used in the next phase of the protocol. This negotiation
          takes only a single round trip, after which the server closes the
          connection and discards all associated state. At this point the NTS-KE
          phase of the protocol is complete. Ideally, the client never needs to
          connect to the NTS-KE server again.
        </t>
        <t>
          Time synchronization proceeds with the indicated NTP server
          over the NTP UDP port. The client sends the server an NTP client
          packet which includes several extension fields. Included among these
          fields are a cookie (previously provided by the key exchange server)
          and an authentication tag, computed using key material extracted from
          the NTS-KE handshake.  The NTP server uses the cookie to recover this
          key material and send back an authenticated response. The response
          includes a fresh, encrypted cookie which the client then sends back in
          the clear in a subsequent request. (This constant refreshing of
          cookies is necessary in order to achieve NTS's unlinkability goal.)
        </t>
        <t>
          <xref target="protocol-overview"/> provides an overview of the
          high-level interaction between the client, the NTS-KE server, and the
          NTP server. Note that the cookies' data format and the exchange of
          secrets between NTS-KE and NTP servers are not part of this
          specification and are implementation dependent. However, a suggested
          format for NTS cookies is provided in
          <xref target="suggested-format-for-nts-cookies"/>.
        </t>
        <figure anchor="protocol-overview"
          title="Overview of High-Level Interactions in NTS">
          <artwork><![CDATA[
                                                     +--------------+
                                                     |              |
                                                 +-> | NTP Server 1 |
                                                 |   |              |
                           Shared cookie         |   +--------------+
+---------------+      encryption parameters     |   +--------------+
|               |    (Implementation dependent)  |   |              |
| NTS-KE Server | <------------------------------+-> | NTP Server 2 |
|               |                                |   |              |
+---------------+                                |   +--------------+
       ^                                         |          .
       |                                         |          .
       | 1. Negotiate parameters,                |          .
       |    receive initial cookie               |   +--------------+
       |    supply, generate AEAD keys,          |   |              |
       |    and receive NTP server IP            +-> | NTP Server N |
       |    addresses using "NTS Key                 |              |
       |    Establishment" protocol.                 +--------------+
       |                                                    ^
       |                                                    |
       |             +----------+                           |
       |             |          |                           |
       +-----------> |  Client  | <-------------------------+
                     |          |  2. Perform authenticated
                     +----------+     time synchronization
                                      and generate new
                                      cookies using "NTS
                                      Extension Fields for
                                      NTPv4".]]>
          </artwork>
        </figure>
      </section>
    </section>

    <section title="Requirements Language">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
        "OPTIONAL" in this document are to be interpreted as described in
        BCP&nbsp;14 <xref target="RFC2119" /> <xref target="RFC8174" /> when,
        and only when, they appear in all capitals, as shown here.
      </t>
    </section>

    <section title="TLS profile for Network Time Security" anchor="tls-profile">
      <t>
        Network Time Security makes use of TLS for NTS key establishment.
      </t>
      <t>
        Since the NTS protocol is new as of this publication, no
        backward-compatibility concerns exist to justify using
        obsolete, insecure, or otherwise broken TLS features or
        versions. Implementations MUST conform with <xref
        target="RFC7525">RFC 7525</xref> or with a later revision of BCP
        195. In particular, failure to use cipher suites that provide forward
        secrecy will make all negotiated NTS keys recoverable by anyone
        that gains access to the NTS-KE server's private key.
        Furthermore:
      </t>
      <t>
        Implementations MUST NOT negotiate TLS versions earlier than
        1.2, SHOULD negotiate TLS 1.3 <xref target="RFC8446"/> or
        later when possible, and MAY refuse to negotiate any TLS
        version which has been superseded by a later supported
        version.
      </t>
      <t>
        Use of the <xref target="RFC7301">Application-Layer Protocol
        Negotiation Extension</xref> is integral to NTS and support for
        it is REQUIRED for interoperability.
      </t>
    </section>

    <section title="The NTS Key Establishment Protocol" anchor="nts-ke">
      <t>
        The NTS key establishment protocol is conducted via TCP port [[TBD1]].
        The two endpoints carry out a TLS handshake in conformance with
        <xref target="tls-profile"/>, with the client offering (via an
        <xref target="RFC7301">ALPN</xref> extension), and the server accepting,
        an application-layer protocol of &quot;ntske/1&quot;. Immediately
        following a successful handshake, the client SHALL send a single request
        as Application Data encapsulated in the TLS-protected channel. Then, the
        server SHALL send a single response. After sending their respective
        request and response, the client and server SHALL send TLS
        &quot;close_notify&quot; alerts in accordance with the TLS version in
        use, see <xref target="RFC8446">RFC 8446 Section 6.1</xref>.
      </t>
      <t>
        The client's request and the server's response each SHALL consist of a
        sequence of records formatted according to
        <xref target="ntske-record"/>. The request and a non-error response each
        SHALL include exactly one NTS Next Protocol Negotiation record. The
        sequence SHALL be terminated by a &quot;End of Message&quot; record. The
        requirement that all NTS-KE messages be terminated by an End of Message
        record makes them self-delimiting.
      </t>
      <t>
        Clients and servers MAY enforce length limits on requests and responses,
        however, servers MUST accept requests of at least 1024 octets and
        clients SHOULD accept responses of at least 65536 octets.
      </t>
      <figure anchor="ntske-record" title="NTS-KE Record Format">
        <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|C|         Record Type         |          Body Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
.                                                               .
.                           Record Body                         .
.                                                               .
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]>
        </artwork>
      </figure>
      <t>
        The fields of an NTS-KE record are defined as follows:
        <list>
          <t>
            C (Critical Bit): Determines the disposition of unrecognized Record
            Types. Implementations which receive a record with an unrecognized
            Record Type MUST ignore the record if the Critical Bit is 0 and MUST
            treat it as an error if the Critical Bit is 1 (see <xref target="nts-error"/>).
          </t>
          <t>
            Record Type Number: A 15-bit integer in network byte order. The
            semantics of record types 0&ndash;7 are specified in this memo.
            Additional type numbers SHALL be tracked through the IANA Network
            Time Security Key Establishment Record Types registry.
          </t>
          <t>
            Body Length: The length of the Record Body field, in octets, as a
            16-bit integer in network byte order. Record bodies MAY have any
            representable length and need not be aligned to a word boundary.
          </t>
          <t>
            Record Body: The syntax and semantics of this field SHALL be
            determined by the Record Type.
          </t>
        </list>
      </t>
      <t>
        For clarity regarding bit-endianness: the Critical Bit is the
        most-significant bit of the first octet. In the C programming language,
        given a network buffer
        `unsigned char b[]` containing an NTS-KE record, the critical bit is
        `b[0] &gt;&gt; 7` while the record type is
        `((b[0] &amp; 0x7f) &lt;&lt; 8) + b[1]`.
      </t>
      <t>
        Note that, although the Type-Length-Body format of an NTS-KE record is
        similar to that of an NTP extension field, the semantics of the length
        field differ. While the length subfield of an NTP extension field gives
        the length of the entire extension field including the type and length
        subfields, the length field of an NTS-KE record gives just the length
        of the body.
      </t>
      <t>
        <xref target="fig_NTSKeyExchange"/> provides a schematic overview of the
        key exchange. It displays the protocol steps to be performed by the NTS
        client and server and record types to be exchanged.
      </t>
      <figure anchor="fig_NTSKeyExchange" title="NTS Key Exchange Messages">
        <artwork><![CDATA[
                +---------------------------------------+
                | - Verify client request message.      |
                | - Extract TLS key material.           |
                | - Generate KE response message.       |
                |   - Include Record Types:             |
                |       o NTS Next Protocol Negotiation |
                |       o AEAD Algorithm Negotiation    |
                |       o NTP Server Negotiation        |
                |       o New Cookie for NTPv4          |
                |       o <New Cookie for NTPv4>        |
                |       o End of Message                |
                +-----------------+---------------------+
                                  |
                                  |
Server -----------+---------------+-----+----------------------->
                  ^                      \
                 /                        \
                /    TLS application       \
               /     data                   \
              /                              \
             /                                V
Client -----+---------------------------------+----------------->
            |                                 |
            |                                 |
            |                                 |
+-----------+----------------------+   +------+-----------------+
|- Generate KE request message.    |   |- Verify server response|
| - Include Record Types:          |   |  message.              |
|  o NTS Next Protocol Negotiation |   |- Extract cookie(s).    |
|  o AEAD Algorithm Negotiation    |   |                        |
|  o <NTP Server Negotiation>      |   |                        |
|  o End of Message                |   |                        |
+----------------------------------+   +------------------------+]]>
        </artwork>
      </figure>

      <section title="NTS-KE Record Types">
        <t>The following NTS-KE Record Types are defined:</t>

        <section title="End of Message" anchor="end-of-message">
          <t>
            The End of Message record has a Record Type number of 0 and a
            zero-length body. It MUST occur exactly once as the final record of
            every NTS-KE request and response. The Critical Bit MUST be set.
          </t>
        </section>

        <section title="NTS Next Protocol Negotiation"
          anchor="nts-next-protocol-negotiation">
          <t>
            The NTS Next Protocol Negotiation record has a Record Type number
            of 1. It MUST occur exactly once in every NTS-KE request and
            response. Its body consists of a sequence of 16-bit unsigned
            integers in network byte order. Each integer represents a Protocol
            ID from the IANA Network Time Security Next Protocols registry. The
            Critical Bit MUST be set.
          </t>
          <t>

            The Protocol IDs listed in the client's NTS Next Protocol
            Negotiation record denote those protocols which the client wishes to
            speak using the key material established through this NTS-KE
            session. Protocol IDs listed in the NTS-KE server's response MUST
            comprise a subset of those listed in the request and
            denote those protocols which the NTP server is willing and
            able to speak using the key material established through
            this NTS-KE session. The client MAY
            proceed with one or more of them. The request MUST list at least one
            protocol, but the response MAY be empty.
          </t>
        </section>

        <section title="Error" anchor="nts-error">
          <t>
            The Error record has a Record Type number of 2. Its body is exactly
            two octets long, consisting of an unsigned 16-bit integer in network
            byte order, denoting an error code. The Critical Bit MUST be set.
          </t>
          <t>
            Clients MUST NOT include Error records in their request. If clients
            receive a server response which includes an Error record, they MUST
            discard any key material negotiated during the initial TLS exchange
            and MUST NOT proceed to the Next Protocol.
          </t>
          <t>
            The following error codes are defined:
            <list>
              <t>
                Error code 0 means &quot;Unrecognized Critical Record&quot;. The
                server MUST respond with this error code if the request included
                a record which the server did not understand and which had its
                Critical Bit set. The client SHOULD NOT retry its request
                without modification.
              </t>
              <t>
                Error code 1 means &quot;Bad Request&quot;. The server MUST
                respond with this error if the request is not complete
                and syntactically well-formed, or, upon the expiration
                of an implementation-defined timeout, it has not yet
                received such a request.
              </t>
              <t>
                Error code 2 means &quot;Internal Server Error&quot;. The server
                MUST respond with this error if it is unable to respond properly
                due to an internal condition.
              </t>
            </list>
          </t>
        </section>

        <section title="Warning" anchor="nts-warning">
          <t>
            The Warning record has a Record Type number of 3. Its body is
            exactly two octets long, consisting of an unsigned 16-bit integer in
            network byte order, denoting a warning code. The Critical Bit MUST
            be set.
          </t>
          <t>
            Clients MUST NOT include Warning records in their request. If
            clients receive a server response which includes a Warning record,
            they MAY discard any negotiated key material and abort without
            proceeding to the Next Protocol. Unrecognized warning codes MUST be
            treated as errors.
          </t>
          <t>
            This memo defines no warning codes.
          </t>
        </section>

        <section title="AEAD Algorithm Negotiation"
          anchor="aead-algorithm-negotiation">
          <t>
            The AEAD Algorithm Negotiation record has a Record Type number of 4.
            Its body consists of a sequence of unsigned 16-bit integers in
            network byte order, denoting Numeric Identifiers from the IANA
            <xref target="IANA-AEAD">AEAD Algorithms registry</xref>. The
            Critical Bit MAY be set.
          </t>
          <t>
            If the NTS Next Protocol Negotiation record offers Protocol ID 0
            (for NTPv4), then this record MUST be included exactly once. Other
            protocols MAY require it as well.
          </t>
          <t>
            When included in a request, this record denotes which AEAD
            algorithms the client is willing to use to secure the Next Protocol,
            in decreasing preference order. When included in a response, this
            record denotes which algorithm the server chooses to use. It is
            empty if the server supports none of the algorithms offered. In
            requests, the list MUST include at least one algorithm. In
            responses, it MUST include at most one. Honoring the client's
            preference order is OPTIONAL: servers may select among any of the
            client's offered choices, even if they are able to support some
            other algorithm which the client prefers more.
          </t>
          <t>
            Server implementations of <xref
            target="nts-extension-fields-for-ntpv4">NTS extension fields for
            NTPv4</xref> MUST support <xref
            target="RFC5297">AEAD_AES_SIV_CMAC_256</xref> (Numeric Identifier
            15). That is, if the client includes AEAD_AES_SIV_CMAC_256 in its
            AEAD Algorithm Negotiation record and the server accepts Protocol
            ID 0 (NTPv4) in its NTS Next Protocol Negotiation record, then the
            server's AEAD Algorithm Negotiation record MUST NOT be empty.
          </t>
        </section>

        <section title="New Cookie for NTPv4" anchor="new-cookie-for-ntpv4">
          <t>
            The New Cookie for NTPv4 record has a Record Type number of 5. The
            contents of its body SHALL be implementation-defined and clients
            MUST NOT attempt to interpret them. See <xref
            target="suggested-format-for-nts-cookies"/> for a suggested
            construction.
          </t>
          <t>
            Clients MUST NOT send records of this type. Servers MUST send at
            least one record of this type, and SHOULD send eight of them, if the
            Next Protocol Negotiation response record contains Protocol ID 0
            (NTPv4) and the AEAD Algorithm Negotiation response record is not
            empty. The Critical Bit SHOULD NOT be set.
          </t>
        </section>

        <section title="NTPv4 Server Negotiation"
                 anchor="ntp-server-negotiation">
          <t>
            The NTPv4 Server Negotiation record has a Record Type number of 6.
            Its body consists of an
            <xref target="RFC0020">ASCII-encoded</xref> string. The
            contents of the string SHALL be either an IPv4 address, an IPv6
            address, or a fully qualified domain name (FQDN). IPv4 addresses
            MUST be in dotted decimal notation. IPv6 addresses MUST conform to
            the "Text Representation of Addresses" as specified in
            <xref target="RFC4291">RFC 4291</xref> and MUST NOT include zone
            identifiers <xref target="RFC6874"/>. If a label contains at least
            one non-ASCII character, it is an internationalized domain name
            and an A-LABEL MUST be used as defined in
            section 2.3.2.1 of <xref target="RFC5890">RFC 5890</xref>.
            If the record contains a domain name, the recipient MUST treat it
            as a FQDN, e.g. by making sure it ends with a dot.
          </t>
          <t>
            When NTPv4 is negotiated as a Next Protocol and this
            record is sent by the server, the body specifies the
            hostname or IP address of the NTPv4 server with which the
            client should associate and which will accept the supplied
            cookies. If no record of this type is sent, the client
            SHALL interpret this as a directive to associate with an
            NTPv4 server at the same IP address as the NTS-KE server.
            Servers MUST NOT send more than one record of this type.
          </t>
          <t>
            When this record is sent by the client, it indicates that
            the client wishes to associate with the specified NTP
            server. The NTS-KE server MAY incorporate this request when
            deciding what NTPv4 Server Negotiation records to respond
            with, but honoring the client's preference is
            OPTIONAL. The client MUST NOT send more than one record of
            this type.
          </t>
          <t>
            If the client has sent a record of this type, the NTS-KE server
            SHOULD reply with the same record if it is valid and the server is
            able to supply cookies for it. If the client has not sent any
            record of this type, the NTS-KE server SHOULD respond with either
            an NTP server address in the same family as the NTS-KE session or
            a FQDN that can be resolved to an address in that family, if such
            alternatives are available.
          </t>
          <t>
            Servers MAY set the Critical Bit on records of this type;
            clients SHOULD NOT.
          </t>
        </section>

        <section title="NTPv4 Port Negotiation"
                 anchor="ntp-port-negotiation">
          <t>
            The NTPv4 Port Negotiation record has a Record Type number
            of 7. Its body consists of a 16-bit unsigned integer in
            network byte order, denoting a UDP port number.
          </t>
          <t>
            When NTPv4 is negotiated as a Next Protocol and this
            record is sent by the server, the body specifies the port
            number of the NTPv4 server with which the client should
            associate and which will accept the supplied cookies. If
            no record of this type is sent, the client SHALL assume
            a default of 123 (the registered port number for NTP).
          </t>
          <t>
            When this record is sent by the client in conjunction with
            a NTPv4 Server Negotiation record, it indicates that the
            client wishes to associate with the NTP server at the
            specified port. The NTS-KE server MAY incorporate this
            request when deciding what NTPv4 Server Negotiation and
            NTPv4 Port Negotiation records to respond with, but
            honoring the client's preference is OPTIONAL.
          </t>
          <t>
            Servers MAY set the Critical Bit on records of this type;
            clients SHOULD NOT.
          </t>
        </section>
      </section>      

      <section title="Key Extraction (generally)" anchor="key-extraction">
        <t>
          Following a successful run of the NTS-KE protocol, key material SHALL
          be extracted using <xref target="RFC5705">the TLS pseudorandom
          function (PRF)</xref> for TLS version 1.2, or
          <xref target="RFC5869">the HMAC-based Extract-and-Expand Key
          Derivation Function (HKDF)</xref> in accordance with
          <xref target="RFC8446">RFC 8446, Section 7.5</xref> for TLS version 1.3.

          Inputs to the exporter function are to be constructed in a manner
          specific to the negotiated Next Protocol. However, all protocols which
          utilize NTS-KE MUST conform to the following two rules:
          <list>
            <t>
              The disambiguating label string MUST be
              &quot;EXPORTER-network-time-security&quot;.
            </t>
            <t>
              The per-association context value MUST be provided and MUST begin
              with the two-octet Protocol ID which was negotiated as a Next
              Protocol.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="NTS Extension Fields for NTPv4"
             anchor="nts-extension-fields-for-ntpv4">
      <section title="Key Extraction (for NTPv4)">
        <t>
          Following a successful run of the NTS-KE protocol wherein Protocol
          ID 0 (NTPv4) is selected as a Next Protocol, two AEAD keys SHALL be
          extracted: a client-to-server (C2S) key and a server-to-client (S2C)
          key. These keys SHALL be computed with the PRF defined in
          <xref target="RFC5705">RFC 5705</xref> for TLS version 1.2, or
          the HKDF defined in <xref target="RFC8446">RFC 8446, Section 7.5</xref>
          for TLS version 1.3, using the following inputs.
          <list>
            <t>
              The disambiguating label string (for PRF) or label (for HKDF)
              SHALL be &quot;EXPORTER-network-time-security&quot;.
            </t>
            <t>
              The context value SHALL consist of the following five octets:
              <list>
                <t>
                  The first two octets SHALL be zero (the Protocol ID for
                  NTPv4).
                </t>
                <t>
                  The next two octets SHALL be the Numeric Identifier of the
                  negotiated AEAD Algorithm in network byte order.
                </t>
                <t>
                  The final octet SHALL be 0x00 for the C2S key and 0x01 for the
                  S2C key.
                </t>
              </list>
            </t>
          </list>
          Implementations wishing to derive additional keys for private or
          experimental use MUST NOT do so by extending the above-specified
          syntax for per-association context values. Instead, they SHOULD use
          their own disambiguating label string. Note that <xref
          target="RFC5705">RFC 5705</xref> provides that disambiguating label
          strings beginning with &quot;EXPERIMENTAL&quot; MAY be used without
          IANA registration.
        </t>
      </section>

      <section title="Packet Structure Overview">
        <t>
          In general, an NTS-protected NTPv4 packet consists of:
          <list>
            <t>
              The usual 48-octet NTP header which is authenticated but not
              encrypted.
            </t>
            <t>
              Some extension fields which are authenticated but not encrypted.
            </t>
            <t>
              An extension field which contains AEAD output (i.e., an
              authentication tag and possible ciphertext). The corresponding
              plaintext, if non-empty, consists of some extension fields which
              benefit from both encryption and authentication.
            </t>
            <t>
              Possibly, some additional extension fields which are neither
              encrypted nor authenticated. In general, these are discarded by the
              receiver.
            </t>
          </list>
        </t>
        <t>
          Always included among the authenticated or authenticated-and-encrypted
          extension fields are a cookie extension field and a unique identifier
          extension field, as described in Section 5.7. The purpose of the
          cookie extension field is to enable the server to offload storage of
          session state onto the client. The purpose of the unique identifier
          extension field is to protect the client from replay attacks.
        </t>
      </section>

      <section title="The Unique Identifier Extension Field"
        anchor="unique-identifier-extension-field">
        <t>
          The Unique Identifier extension field provides the client with a
          cryptographically strong means of detecting replayed packets. It has a
          Field Type of [[TBD2]]. When the extension field is included in a
          client packet (mode 3), its body SHALL consist of a string of octets
          generated uniformly at random. The string MUST be at least 32 octets
          long. When the extension field is included in a server packet
          (mode 4), its body SHALL contain the same octet string as was provided
          in the client packet to which the server is responding. All server
          packets generated by NTS-implementing servers in response to client
          packets containing this extension field MUST also contain this field
          with the same content as in the client's request. The field's use in
          modes other than client-server is not defined.
        </t>
        <t>
          This extension field MAY also be used standalone, without NTS, in
          which case it provides the client with a means of detecting spoofed
          packets from off-path attackers. Historically, NTP's origin timestamp
          field has played both these roles, but for cryptographic purposes this
          is suboptimal because it is only 64 bits long and, depending on
          implementation details, most of those bits may be predictable. In
          contrast, the Unique Identifier extension field enables a degree of
          unpredictability and collision resistance more consistent with
          cryptographic best practice.
        </t>
      </section>

      <section title="The NTS Cookie Extension Field"
        anchor="nts-cookie-extension-field">
        <t>
          The NTS Cookie extension field has a Field Type of [[TBD3]]. Its
          purpose is to carry information which enables the server to recompute
          keys and other session state without having to store any per-client
          state. The contents of its body SHALL be implementation-defined and
          clients MUST NOT attempt to interpret them. See <xref
          target="suggested-format-for-nts-cookies"/> for a suggested
          construction.  The NTS Cookie extension field MUST NOT be included in
          NTP packets whose mode is other than 3 (client) or 4 (server).
        </t>
      </section>

      <section title="The NTS Cookie Placeholder Extension Field"
        anchor="nts-cookie-placeholder-extension-field">
        <t>
          The NTS Cookie Placeholder extension field has a Field Type of
          [[TBD4]].  When this extension field is included in a client packet
          (mode 3), it communicates to the server that the client wishes it to
          send additional cookies in its response. This extension field MUST NOT
          be included in NTP packets whose mode is other than 3.
        </t>
        <t>
          Whenever an NTS Cookie Placeholder extension field is present, it MUST
          be accompanied by an NTS Cookie extension field. The body length of
          the NTS Cookie Placeholder extension field MUST be the same as the
          body length of the NTS Cookie extension field. This length requirement
          serves to ensure that the response will not be larger than the
          request, in order to improve timekeeping precision and prevent DDoS
          amplification. The contents of the NTS Cookie Placeholder extension
          field's body SHOULD be all zeros and, aside from checking its length,
          MUST be ignored by the server.
        </t>
      </section>

      <section title="The NTS Authenticator and Encrypted Extension Fields Extension Field"
        anchor="nts-aeef-extension-field">
        <t>
          The NTS Authenticator and Encrypted Extension Fields extension field
          is the central cryptographic element of an NTS-protected NTP packet.
          Its Field Type is [[TBD5]]. It SHALL be formatted according to
          <xref target="fig-aeef-field"/> and include the following fields:
          <list>
            <t>
              Nonce Length: Two octets in network byte order, giving the length
              of the Nonce field, excluding any padding, interpreted as an
              unsigned integer.
            </t>
            <t>
              Ciphertext Length: Two octets in network byte order, giving the
              length of the Ciphertext field, excluding any padding, interpreted
              as an unsigned integer.
            </t>
            <t>
              Nonce: A nonce as required by the negotiated AEAD Algorithm. The
              end of the field is zero-padded to a word (four octets) boundary.
            </t>
            <t>
              Ciphertext: The output of the negotiated AEAD Algorithm. The
              structure of this field is determined by the negotiated algorithm,
              but it typically contains an authentication tag in addition to the
              actual ciphertext. The end of the field is zero-padded to a word
              (four octets) boundary.
            </t>
            <t>
              Additional Padding: Clients which use a nonce length shorter than
              the maximum allowed by the negotiated AEAD algorithm may be required
              to include additional zero-padding. The necessary length of this
              field is specified below.
            </t>
          </list>
        </t>
        <figure anchor="fig-aeef-field"
          title="NTS Authenticator and Encrypted Extension Fields Extension Field Format">
          <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Nonce Length         |      Ciphertext Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
.                                                               .
.          Nonce, including up to 3 octets padding              .
.                                                               .
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
.                                                               .
.        Ciphertext, including up to 3 octets padding           .
.                                                               .
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
.                                                               .
.                      Additional Padding                       .
.                                                               .
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]>
          </artwork>
        </figure>
        <t>
          The Ciphertext field SHALL be formed by providing the following inputs
          to the negotiated AEAD Algorithm:
          <list>
            <t>
              K: For packets sent from the client to the server, the C2S key
              SHALL be used. For packets sent from the server to the client, the
              S2C key SHALL be used.
            </t>
            <t>
              A: The associated data SHALL consist of the portion of the NTP
              packet beginning from the start of the NTP header and ending at
              the end of the last extension field which precedes the NTS
              Authenticator and Encrypted Extension Fields extension field.
            </t>
            <t>
              P: The plaintext SHALL consist of all (if any) NTP extension fields to
              be encrypted; if multiple extension fields are present they SHALL be
              joined by concatenation. Each such field SHALL be formatted in
              accordance with RFC 7822 [RFC7822], except that, contrary to the RFC
              7822 requirement that fields have a minimum length of 16 or 28 octets,
              encrypted extension fields MAY be arbitrarily short (but still MUST be
              a multiple of 4 octets in length).
            </t>
            <t>
              N: The nonce SHALL be formed however required by the negotiated
              AEAD algorithm.
            </t>
          </list>
        </t>
        <t>
          The purpose of the Additional Padding field is to ensure
          that servers can always choose a nonce whose length is
          adequate to ensure its uniqueness, even if the client
          chooses a shorter one, and still ensure that the overall
          length of the server's response packet does not exceed the
          length of the request. For mode 4 (server) packets, no
          Additional Padding field is ever required.  For mode 3
          (client) packets, the length of the Additional Padding field
          SHALL be computed as follows.  Let `N_LEN` be the padded
          length of the Nonce field. Let `N_MAX` be, as specified
          by <xref target="RFC5116">RFC 5116</xref>, the maximum
          permitted nonce length for the negotiated AEAD
          algorithm. Let `N_REQ` be the lesser of 16 and N_MAX,
          rounded up to the nearest multiple of 4.  If N_LEN is
          greater than or equal to N_REQ, then no Additional Padding
          field is required. Otherwise, the Additional Padding field
          SHALL be at least N_REQ - N_LEN octets in length. Servers
          MUST enforce this requirement by discarding any packet which
          does not conform to it.
        </t>
        <t>
          Senders are always free to include more Additional Padding
          than mandated by the above paragraph. Theoretically, it
          could be necessary to do so in order to bring the extension
          field to the minimum length required by <xref
          target="RFC7822">RFC 7822</xref>. This should never happen in
          practice because any reasonable AEAD algorithm will have a nonce and
          an authenticator long enough to bring the extension field to
          its required length already.  Nonetheless, implementers are
          advised to explicitly handle this case and ensure that the
          extension field they emit is of legal length.
        </t>
        <t>
          The NTS Authenticator and Encrypted Extension Fields extension field
          MUST NOT be included in NTP packets whose mode is other than 3
          (client) or 4 (server).
        </t>
      </section>

      <section title="Protocol Details" anchor="protocol-details">
        <t>
          A client sending an NTS-protected request SHALL include the following
          extension fields as displayed in  <xref
          target="fig_NTSTimeSyncMessage"/>:
          <list>
            <t>
              Exactly one Unique Identifier extension field which MUST be
              authenticated, MUST NOT be encrypted, and whose contents MUST be
              the output of a cryptographically secure random number generator.
              <xref target="RFC4086"/>
            </t>
            <t>
              Exactly one NTS Cookie extension field which MUST be authenticated
              and MUST NOT be encrypted. The cookie MUST be one which has been
              previously provided to the client, either from the key exchange
              server during the NTS-KE handshake or from the NTP server in
              response to a previous NTS-protected NTP request.
            </t>
            <t>
              Exactly one NTS Authenticator and Encrypted Extension Fields
              extension field, generated using an AEAD Algorithm and C2S key
              established through NTS-KE.
            </t>
          </list>
        </t>
        <t>
          To protect the client's privacy, the client SHOULD avoid reusing
          a cookie. If the client does not have any cookies that it has not
          already sent, it SHOULD initiate a re-run of the NTS-KE protocol. The
          client MAY reuse cookies in order to prioritize resilience over
          unlinkability. Which of the two that should be prioritized in any
          particular case is dependent on the application and the user's
          preference. <xref target="Unlinkability"/> describes the privacy
          considerations of this in further detail.
        </t>
        <t>
          The client MAY include one or more NTS Cookie Placeholder extension
          fields which MUST be authenticated and MAY be encrypted. The number of
          NTS Cookie Placeholder extension fields that the client includes
          SHOULD be such that if the client includes N placeholders and the server
          sends back N+1 cookies, the number of unused cookies stored by the
          client will come to eight. The client SHOULD NOT include more than seven
          NTS Cookie Placeholder extension fields in a request. When both the
          client and server adhere to all cookie-management guidance provided in
          this memo, the number of placeholder extension fields will equal the
          number of dropped packets since the last successful volley.
        </t>
        <t>
          In rare circumstances, it may be necessary to include fewer
          NTS Cookie Placeholder extensions than recommended above in
          order to prevent datagram fragmentation. When cookies adhere
          the format recommended in <xref
          target="suggested-format-for-nts-cookies"/> and the AEAD in
          use is the mandatory-to-implement AEAD_AES_SIV_CMAC_256,
          senders can include a cookie and seven placeholders and
          still have packet size fall comfortably below 1280 octets if
          no non-NTS-related extensions are used; 1280 octets is the
          minimum prescribed MTU for IPv6 and is generally safe
          for avoiding IPv4 fragmentation. Nonetheless,
          senders SHOULD include fewer cookies and placeholders than
          otherwise indicated if doing so is necessary to prevent
          fragmentation.
        </t>
        <figure anchor="fig_NTSTimeSyncMessage"
          title="NTS-protected NTP Time Synchronization Messages">
          <artwork><![CDATA[
                +---------------------------------------+
                | - Verify time request message         |
                | - Generate time response message      |
                |   - Included NTPv4 extension fields   |
                |      o Unique Identifier EF           |
                |      o NTS Authentication and         |
                |        Encrypted Extension Fields EF  |
                |        - NTS Cookie EF                |
                |        - <NTS Cookie EF>              |
                | - Transmit time request packet        |
                +-----------------+---------------------+
                                  |
                                  |
Server -----------+---------------+-----+----------------------->
                  ^                      \          
                 /                        \      
  Time request  /                          \   Time response
  (mode 3)     /                            \  (mode 4)  
              /                              \   
             /                                V 
Client -----+---------------------------------+----------------->
            |                                 |
            |                                 |
            |                                 |
+-----------+----------------------+   +------+-----------------+
|- Generate time request message   |   |- Verify time response  |
| - Include NTPv4 Extension fields |   |  message               |
|    o Unique Identifier EF        |   |- Extract cookie(s)     |
|    o NTS Cookie EF               |   |- Time synchronization  |
|    o <NTS Cookie Placeholder EF> |   |  processing            |
|                                  |   +------------------------+
|- Generate AEAD tag of NTP message|
|- Add NTS Authentication and      |
|  Encrypted Extension Fields EF   |
|- Transmit time request packet    | 
+----------------------------------+]]>
          </artwork>
        </figure>
        <t>
          The client MAY include additional (non-NTS-related) extension fields
          which MAY appear prior to the NTS Authenticator and Encrypted Extension
          Fields extension fields (therefore authenticated but not encrypted),
          within it (therefore encrypted and authenticated), or after it
          (therefore neither encrypted nor authenticated).
          The server MUST discard any unauthenticated extension
          fields. Future specifications of extension fields MAY provide
          exceptions to this rule.
        </t>
        <t>
          Upon receiving an NTS-protected request, the server SHALL (through some
          implementation-defined mechanism) use the cookie to recover the AEAD
          Algorithm, C2S key, and S2C key associated with the request, and then
          use the C2S key to authenticate the packet and decrypt the ciphertext.
          If the cookie is valid and authentication and decryption succeed, the
          server SHALL include the following extension fields in its response:
          <list>
            <t>
              Exactly one Unique Identifier extension field which MUST be
              authenticated, MUST NOT be encrypted, and whose contents SHALL echo
              those provided by the client.
            </t>
            <t>
              Exactly one NTS Authenticator and Encrypted Extension Fields
              extension field, generated using the AEAD algorithm and S2C key
              recovered from the cookie provided by the client.
            </t>
            <t>
              One or more NTS Cookie extension fields which MUST be authenticated
              and encrypted. The number of NTS Cookie extension fields included
              SHOULD be equal to, and MUST NOT exceed, one plus the number of
              valid NTS Cookie Placeholder extension fields included in the
              request. The cookies returned in those fields MUST be valid for use
              with the NTP server that sent them. They MAY be valid for other NTP
              servers as well, but there is no way for the server to indicate
              this.
            </t>
          </list>
        </t>
        <t>
          We emphasize the contrast that NTS Cookie extension fields MUST NOT be
          encrypted when sent from client to server, but MUST be encrypted when
          sent from server to client. The former is necessary in order for the
          server to be able to recover the C2S and S2C keys, while the latter is
          necessary to satisfy the unlinkability goals discussed in <xref
          target="Unlinkability"/>. We emphasize also that &quot;encrypted&quot;
          means encapsulated within the NTS Authenticator and Encrypted
          Extensions extension field. While the body of an NTS Cookie extension
          field will generally consist of some sort of AEAD output (regardless of
          whether the recommendations of <xref
          target="suggested-format-for-nts-cookies"/> are precisely followed),
          this is not sufficient to make the extension field
          &quot;encrypted&quot;.
        </t>
        <t>
          The server MAY include additional (non-NTS-related) extension fields
          which MAY appear prior to the NTS Authenticator and Encrypted Extension
          Fields extension field (therefore authenticated but not encrypted),
          within it (therefore encrypted and authenticated), or after it
          (therefore neither encrypted nor authenticated).
          The client MUST discard any unauthenticated extension fields.
          Future specifications of extension fields MAY provide exceptions to
          this rule.
        </t>
        <t>
          Upon receiving an NTS-protected response, the client MUST verify that
          the Unique Identifier matches that of an outstanding request, and that
          the packet is authentic under the S2C key associated with that request.
          If either of these checks fails, the packet MUST be discarded without
          further processing.
        </t>
        <t>
          If the server is unable to validate the cookie or authenticate the
          request, it SHOULD respond with a Kiss-o'-Death (KoD) packet (see
          <xref target="RFC5905">RFC 5905, Section 7.4</xref>) with kiss code
          &quot;NTSN&quot;, meaning &quot;NTS NAK&quot; (NTS negative-acknowledgment).
          It MUST NOT include any NTS Cookie or NTS Authenticator and
          Encrypted Extension Fields extension fields.
        </t>
        <t>
          If the NTP server has previously responded with authentic NTS-protected
          NTP packets, the client MUST verify that
          any KoD packets received from the server contain the Unique Identifier
          extension field and that the Unique Identifier matches that of an
          outstanding request. If this check fails, the packet MUST be discarded
          without further processing. If this check passes, the client MUST comply
          with <xref target="RFC5905">RFC 5905, Section 7.4</xref> where required.
          A client MAY automatically re-run the NTS-KE protocol upon forced
          disassociation from an NTP server. In that case, it MUST avoid quickly
          looping between the NTS-KE and NTP servers by rate limiting the
          retries using, for example, exponential retry intervals. A reasonable
          maximum retry interval could be 7 days, depending on the application.
        </t>
        <t>
          Upon reception of the NTS NAK kiss code, the client SHOULD wait until
          the next poll for a valid NTS-protected response and if none is
          received, initiate a fresh NTS-KE handshake to try to renegotiate new
          cookies, AEAD keys, and parameters. If the NTS-KE handshake succeeds,
          the client MUST discard all old cookies and parameters and use the new
          ones instead. As long as the NTS-KE handshake has not succeeded, the
          client SHOULD continue polling the NTP server using the cookies and
          parameters it has.
        </t>
        <t>
          To allow for NTP session restart when the NTS-KE server is unavailable
          and to reduce NTS-KE server load, the client SHOULD keep at least one
          unused but recent cookie, AEAD keys, negotiated AEAD algorithm, and
          other necessary parameters on persistent storage. This way, the client
          is able to resume the NTP session without performing renewed NTS-KE
          negotiation.
        </t>
      </section>      
    </section>

    <section title="Suggested Format for NTS Cookies"
      anchor="suggested-format-for-nts-cookies">
      <t>
        This section is non-normative. It gives a suggested way for servers to
        construct NTS cookies. All normative requirements are stated in
        <xref target="new-cookie-for-ntpv4"/> and <xref
        target="nts-cookie-extension-field"/>.
      </t>
      <t>
        The role of cookies in NTS is closely analogous to that of session
        cookies in TLS. Accordingly, the thematic resemblance of this section to
        <xref target="RFC5077">RFC 5077</xref> is deliberate and the reader
        should likewise take heed of its security considerations.
      </t>
      <t>
        Servers should select an AEAD algorithm which they will use to encrypt
        and authenticate cookies. The chosen algorithm should be one such as
        <xref target="RFC5297">AEAD_AES_SIV_CMAC_256</xref> which resists
        accidental nonce reuse. It need not be the same as the one that was
        negotiated with the client. Servers should randomly generate and store a
        master AEAD key `K`. Servers should additionally choose a non-secret,
        unique value `I` as key-identifier for `K`.
      </t>
      <t>
        Servers should periodically (e.g., once daily) generate a new pair (I,K)
        and immediately switch to using these values for all newly-generated
        cookies. Following each such key rotation, servers should
        securely erase any previously generated keys that should now be expired.
        Servers should continue to accept any cookie generated using keys that
        they have not yet erased, even if those keys are no longer current.
        Erasing old keys provides for forward secrecy, limiting the scope of
        what old information can be stolen if a master key is somehow
        compromised. Holding on to a limited number of old keys allows clients
        to seamlessly transition from one generation to the next without having
        to perform a new NTS-KE handshake.
      </t>
      <t>
        The need to keep keys synchronized between NTS-KE and NTP servers as
        well as across load-balanced clusters can make automatic key rotation
        challenging. However, the task can be accomplished without the need for
        central key-management infrastructure by using a ratchet, i.e., making
        each new key a deterministic, cryptographically pseudo-random function
        of its predecessor. A recommended concrete implementation of this
        approach is to use <xref target="RFC5869">HKDF</xref> to derive new
        keys, using the key's predecessor as Input Keying Material and its key
        identifier as a salt.
      </t>
      <t>
        To form a cookie, servers should first form a plaintext `P` consisting
        of the following fields:
        <list>
          <t>The AEAD algorithm negotiated during NTS-KE.</t>
          <t>The S2C key.</t>
          <t>The C2S key.</t>
        </list>
      </t>
      <t>
        Servers should then generate a nonce `N` uniformly at random, and form
        AEAD output `C` by encrypting `P` under key `K` with nonce `N` and no
        associated data.
      </t>
      <t>
        The cookie should consist of the tuple `(I,N,C)`.
      </t>
      <t>
        To verify and decrypt a cookie provided by the client, first parse it
        into its components `I`, `N`, and `C`. Use `I` to look up its decryption
        key `K`. If the key whose identifier is `I` has been erased or never
        existed, decryption fails; reply with an NTS NAK. Otherwise, attempt to
        decrypt and verify ciphertext `C` using key `K` and nonce `N` with no
        associated data. If decryption or verification fails, reply with an NTS
        NAK. Otherwise, parse out the contents of the resulting plaintext `P` to
        obtain the negotiated AEAD algorithm, S2C key, and C2S key.
      </t>
    </section>

    <section title="IANA Considerations" anchor="iana-considerations">
      <section title="Service Name and Transport Protocol Port Number Registry">
        <t>
          IANA is requested to allocate the following entry in the
          <xref target="RFC6335">Service Name and Transport Protocol
          Port Number Registry</xref>:
          <list>
            <t>Service Name: ntske</t>
            <t>Transport Protocol: tcp</t>
            <t>Assignee: IESG &lt;iesg@ietf.org&gt;</t>
            <t>Contact: IETF Chair &lt;chair@ietf.org&gt;</t>
            <t>Description: Network Time Security Key Exchange</t>
            <t>Reference: [[this memo]]</t>
            <t>Port Number: [[TBD1]], selected by IANA from the User Port
              range</t>
          </list>
        </t>
        <t>
          [[RFC EDITOR: Replace all instances of [[TBD1]] in this
          document with the IANA port assignment.]]
        </t>
      </section>

      <section title="TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs Registry">
        <t>
          IANA is requested to allocate the following entry in the
          <xref target="RFC7301">TLS Application-Layer Protocol Negotiation
            (ALPN) Protocol IDs registry</xref>:
          <list>
            <t>Protocol: Network Time Security Key Establishment, version 1</t>
            <t>
              Identification Sequence:<vspace/>
              &nbsp;&nbsp;0x6E&nbsp;0x74&nbsp;0x73&nbsp;0x6B&nbsp;0x65&nbsp;0x2F&nbsp;0x31&nbsp;(&quot;ntske/1&quot;)
            </t>
            <t>Reference: [[this memo]], <xref target="nts-ke"/></t>
          </list>
        </t>
      </section>

      <section title="TLS Exporter Labels Registry">
        <t>
          IANA is requested to allocate the following entry in the
          <xref target="RFC5705">TLS Exporter Labels Registry</xref>:
        </t>
        <texttable>
          <ttcol>Value</ttcol>
          <ttcol>DTLS-OK</ttcol>
          <ttcol>Recommended</ttcol>
          <ttcol>Reference</ttcol>
          <ttcol>Note</ttcol>

          <c>EXPORTER-network- time-security</c>
          <c>Y</c>
          <c>Y</c>
          <c>[[this memo]], <xref target="key-extraction"/></c>
          <c/>
        </texttable>
      </section>

      <section title="NTP Kiss-o'-Death Codes Registry">
        <t>
          IANA is requested to allocate the following entry in the
          <xref target="RFC5905">registry of NTP Kiss-o'-Death Codes</xref>:
        </t>
        <texttable>
          <ttcol>Code</ttcol>
          <ttcol>Meaning</ttcol>
          <ttcol>Reference</ttcol>

          <c>NTSN</c>
          <c>Network Time Security (NTS) negative-acknowledgment (NAK)</c>
          <c>[[this memo]], <xref target="protocol-details"/></c>
        </texttable>
      </section>

      <section title="NTP Extension Field Types Registry">
        <t>
          IANA is requested to allocate the following entries in the
          <xref target="RFC5905">NTP Extension Field Types registry</xref>:
        </t>
        <texttable>
          <ttcol>Field Type</ttcol>
          <ttcol>Meaning</ttcol>
          <ttcol>Reference</ttcol>

          <c>[[TBD2]]</c>
          <c>Unique Identifier</c>
          <c>[[this memo]],
            <xref target="unique-identifier-extension-field"/></c>

          <c>[[TBD3]]</c>
          <c>NTS Cookie</c>
          <c>[[this memo]], <xref target="nts-cookie-extension-field"/></c>

          <c>[[TBD4]]</c>
          <c>NTS Cookie Placeholder</c>
          <c>[[this memo]],
            <xref target="nts-cookie-placeholder-extension-field"/></c>

          <c>[[TBD5]]</c>
          <c>NTS Authenticator and Encrypted Extension Fields</c>
          <c>[[this memo]], <xref target="nts-aeef-extension-field"/></c>
        </texttable>
        <t>
          [[RFC EDITOR: REMOVE BEFORE PUBLICATION - The NTP WG suggests that the following values be used:
          <figure>
            <artwork>
Unique Identifier    0x0104
NTS Cookie           0x0204
Cookie Placeholder   0x0304
NTS Authenticator    0x0404]]
            </artwork>
          </figure>
        </t>
        <t>
          [[RFC EDITOR: Replace all instances of [[TBD2]], [[TBD3]], [[TBD4]], and
          [[TBD5]] in this document with the respective IANA assignments.]]
        </t>
      </section>

      <section title="Network Time Security Key Establishment Record Types Registry">
        <t>
          IANA is requested to create a new registry entitled
          &quot;Network Time Security Key Establishment Record Types&quot;.
          Entries SHALL have the following fields:
          <list>
            <t>
              Record Type Number (REQUIRED): An integer in the range
              0&ndash;32767 inclusive.
            </t>
            <t>
              Description (REQUIRED): A short text description of the purpose of
              the field.
            </t>
            <t>
              Reference (REQUIRED): A reference to a document specifying the
              semantics of the record.
            </t>
          </list>
        </t>
        <t>
          The policy for allocation of new entries in this registry SHALL vary
          by the Record Type Number, as follows:
          <list>
            <t>0&ndash;1023: IETF Review</t>
            <t>1024&ndash;16383: Specification Required</t>
            <t>16384&ndash;32767: Private and Experimental Use</t>
          </list>
        </t>
        <t>
          The initial contents of this registry SHALL be as follows:
        </t>
        <texttable>
          <ttcol>Record Type Number</ttcol>
          <ttcol>Description</ttcol>
          <ttcol>Reference</ttcol>

          <c>0</c>
          <c>End of Message</c>
          <c>[[this memo]], <xref target="end-of-message"/></c>

          <c>1</c>
          <c>NTS Next Protocol Negotiation</c>
          <c>[[this memo]],
            <xref target="nts-next-protocol-negotiation"/></c>

          <c>2</c>
          <c>Error</c>
          <c>[[this memo]], <xref target="nts-error"/></c>

          <c>3</c>
          <c>Warning</c>
          <c>[[this memo]], <xref target="nts-warning"/></c>

          <c>4</c>
          <c>AEAD Algorithm Negotiation</c>
          <c>[[this memo]], <xref target="aead-algorithm-negotiation"/></c>

          <c>5</c>
          <c>New Cookie for NTPv4</c>
          <c>[[this memo]], <xref target="new-cookie-for-ntpv4"/></c>

          <c>6</c>
          <c>NTPv4 Server Negotiation</c>
          <c>[[this memo]], <xref target="ntp-server-negotiation"/></c>

          <c>7</c>
          <c>NTPv4 Port Negotiation</c>
          <c>[[this memo]], <xref target="ntp-port-negotiation"/></c>

          <c>16384&ndash;32767</c>
          <c>Reserved for Private &amp; Experimental Use</c>
          <c>[[this memo]]</c>
        </texttable>
      </section>

      <section title="Network Time Security Next Protocols Registry">
        <t>
          IANA is requested to create a new registry entitled
          &quot;Network Time Security Next Protocols&quot;. Entries SHALL have
          the following fields:
          <list>
            <t>
              Protocol ID (REQUIRED): An integer in the range 0-65535 inclusive,
              functioning as an identifier.
            </t>
            <t>
              Protocol Name (REQUIRED): A short text string naming the protocol
              being identified.
            </t>
            <t>
              Reference (REQUIRED): A reference to a relevant specification
              document.
            </t>
          </list>
          The policy for allocation of new entries in these registries
          SHALL vary by their Protocol ID, as follows:
          <list>
            <t>0&ndash;1023: IETF Review</t>
            <t>1024&ndash;32767: Specification Required</t>
            <t>32768&ndash;65535: Private and Experimental Use</t>
          </list>
        </t>
        <t>
          The initial contents of this registry SHALL be as follows:
        </t>
        <texttable>
          <ttcol>Protocol ID</ttcol>
          <ttcol>Protocol Name</ttcol>
          <ttcol>Reference</ttcol>

          <c>0</c>
          <c>Network Time Protocol version 4 (NTPv4)</c>
          <c>[[this memo]]</c>

          <c>32768-65535</c>
          <c>Reserved for Private or Experimental Use</c>
          <c>Reserved by [[this memo]]</c>
        </texttable>
      </section>

      <section title="Network Time Security Error and Warning Codes Registries">
        <t>
          IANA is requested to create two new registries entitled
          &quot;Network Time Security Error Codes&quot; and
          &quot;Network Time Security Warning Codes&quot;. Entries in each SHALL
          have the following fields:
          <list>
            <t>Number (REQUIRED): An integer in the range 0-65535 inclusive</t>
            <t>Description (REQUIRED): A short text description of the
              condition.</t>
            <t>Reference (REQUIRED): A reference to a relevant specification
              document.</t>
          </list>
          The policy for allocation of new entries in these registries SHALL
          vary by their Number, as follows:
          <list>
            <t>0&ndash;1023: IETF Review</t>
            <t>1024&ndash;32767: Specification Required</t>
            <t>32768&ndash;65535: Private and Experimental Use</t>
          </list>
        </t>
        <t>
          The initial contents of the Network Time Security Error Codes Registry
          SHALL be as follows:
        </t>
        <texttable>
          <ttcol>Number</ttcol>
          <ttcol>Description</ttcol>
          <ttcol>Reference</ttcol>

          <c>0</c>
          <c>Unrecognized Critical Extension</c>
          <c>[[this memo]], <xref target="nts-error"/></c>

          <c>1</c>
          <c>Bad Request</c>
          <c>[[this memo]], <xref target="nts-error"/></c>

          <c>2</c>
          <c>Internal Server Error</c>
          <c>[[this memo]], <xref target="nts-error"/></c>

          <c>32768-65535</c>
          <c>Reserved for Private or Experimental Use</c>
          <c>Reserved by [[this memo]]</c>
        </texttable>
        <t>
          The Network Time Security Warning Codes Registry SHALL
          initially be empty except for the reserved range, i.e.:
        </t>
        <texttable>
          <ttcol>Number</ttcol>
          <ttcol>Description</ttcol>
          <ttcol>Reference</ttcol>

          <c>32768-65535</c>
          <c>Reserved for Private or Experimental Use</c>
          <c>Reserved by [[this memo]]</c>
        </texttable>

      </section>
    </section>

    <section title="Implementation Status - RFC EDITOR: REMOVE BEFORE PUBLICATION">
      <t>This section records the status of known implementations of the
      protocol defined by this specification at the time of posting of this
      Internet-Draft, and is based on a proposal described in RFC 7942. The
      description of implementations in this section is intended to assist the
      IETF in its decision processes in progressing drafts to RFCs. Please
      note that the listing of any individual implementation here does not
      imply endorsement by the IETF. Furthermore, no effort has been spent to
      verify the information presented here that was supplied by IETF
      contributors. This is not intended as, and must not be construed to be,
      a catalog of available implementations or their features. Readers are
      advised to note that other implementations may exist.</t>

      <t>According to RFC 7942, "this will allow reviewers and working groups
      to assign due consideration to documents that have the benefit of
      running code, which may serve as evidence of valuable experimentation
      and feedback that have made the implemented protocols more mature. It is
      up to the individual working groups to use this information as they see
      fit".</t>

      <section title="Implementation 1">
        <t>Organization: Ostfalia University of Applied Science</t>

        <t>Implementor: Martin Langer</t>

        <t>Maturity: Proof-of-Concept Prototype</t>

        <t>This implementation was used to verify consistency and to ensure
        completeness of this specification.</t>

        <section title="Coverage">
          <t>This implementation covers the complete specification.</t>
        </section>

        <section title="Licensing">
          <t>The code is released under a Apache License 2.0 license. </t>

          <t>The source code is available at:
          https://gitlab.com/MLanger/nts/</t>
        </section>

        <section title="Contact Information">
          <t>Contact Martin Langer: mart.langer@ostfalia.de</t>
        </section>

        <section title="Last Update">
          <t>The implementation was updated 25. February 2019.</t>
        </section>
      </section>

      <section title="Implementation 2">
        <t>Organization: Netnod</t>

        <t>Implementor: Christer Weinigel</t>

        <t>Maturity: Proof-of-Concept Prototype</t>

        <t>This implementation was used to verify consistency and to ensure
        completeness of this specification. </t>

        <section title="Coverage">
          <t>This implementation covers the complete specification.</t>
        </section>

        <section title="Licensing">

          <t>The source code is available at:
          https://github.com/Netnod/nts-poc-python.</t>
		
	  <t>See LICENSE file for details on licensing (BSD 2).</t>
        </section>

        <section title="Contact Information">
          <t>Contact Christer Weinigel: christer@weinigel.se</t>
        </section>

        <section title="Last Update">
          <t>The implementation was updated 31. January 2019.</t>
        </section>
      </section>
      
      <section title="Implementation 3">
        <t>Organization: Red Hat</t>

        <t>Implementor: Miroslav Lichvar</t>

        <t>Maturity: Prototype</t>

        <t>This implementation was used to verify consistency and to ensure
        completeness of this specification. </t>

        <section title="Coverage">
          <t>This implementation covers the complete specification.</t>
        </section>

        <section title="Licensing">
          <t>Licensing is GPLv2.</t>

          <t>The source code is available at:
          https://github.com/mlichvar/chrony-nts</t>
        </section>

        <section title="Contact Information">
          <t>Contact Miroslav Lichvar: mlichvar@redhat.com</t>
        </section>

        <section title="Last Update">
          <t>The implementation was updated 28. March 2019.</t>
        </section>
      </section>
      
      <section title="Implementation 4">
        <t>Organization: NTPsec</t>

        <t>Implementor: Hal Murray and NTPsec team</t>

        <t>Maturity:Looking for testers. Servers running at ntp1.glypnod.com:123 and ntp2.glypnod.com:123 </t>

        <t>This implementation was used to verify consistency and to ensure
        completeness of this specification. </t>

        <section title="Coverage">
          <t>This implementation covers the complete specification.</t>
        </section>

        <section title="Licensing">
          <t>The source code is available at: https://gitlab.com/NTPsec/ntpsec. Licensing details in LICENSE.</t>

        </section>

        <section title="Contact Information">
          <t>Contact Hal Murray: hmurray@megapathdsl.net, devel@ntpsec.org</t>
        </section>

        <section title="Last Update">
          <t>The implementation was updated 2019-Apr-10.</t>
        </section>
      </section>

      <section title="Implementation 5">
        <t>Organization: Cloudflare</t>

        <t>Implementor: Watson Ladd</t>

        <t>Maturity: </t>

        <t>This implementation was used to verify consistency and to ensure
        completeness of this specification. </t>

        <section title="Coverage">
          <t>This implementation covers the server side of the 
          NTS specification.</t>
        </section>

        <section title="Licensing">
          <t>The source code is available at:
          https://github.com/wbl/nts-rust</t>
		
	   <t>Licensing is ISC (details see LICENSE.txt file).</t>
        </section>

        <section title="Contact Information">
          <t>Contact Watson Ladd: watson@cloudflare.com</t>
        </section>

        <section title="Last Update">
          <t>The implementation was updated 21. March 2019.</t>
        </section>
      </section>

      <section title="Implementation 6">
        <t>Organization: Hacklunch, independent</t>

        <t>Implementor: Michael Cardell Widerkrantz, Daniel Lublin,
          Martin Samuelsson et. al.</t>

        <t>Maturity: interoperable client, immature server</t>

        <section title="Coverage">
          <t>NTS-KE client and server.</t>
        </section>

        <section title="Licensing">
          <t>Licensing is ISC (details in LICENSE file).</t>

          <t>Source code is available at:
            https://gitlab.com/hacklunch/ntsclient</t>
        </section>

        <section title="Contact Information">
          <t>Contact Michael Cardell Widerkrantz: mc@netnod.se</t>
        </section>

        <section title="Last Update">
          <t>The implementation was updated 6. February 2020.</t>
        </section>
      </section>

      <section title="Interoperability ">
        <t>The Interoperability tests distinguished between NTS key
        establishment protocol and NTS time exchange messages. 
        For the implementations 1, 2, 3, and 4 pairwise interoperability of 
        the NTS key establishment protocol and exchange
        of NTS protected NTP messages have been verified successfully. 
        The implementation 2 was able to successfully perform the key establishment
        protocol against the server side of the implementation 5.
        </t>
        <t>These tests successfully
        demonstrate that there are at least four running implementations
        of this draft which are able to interoperate.
        </t>
      </section>
    </section>

    <section title="Security Considerations">
      <section title="Protected Modes">
        <t>
          NTP provides many different operating modes in order to support different
          network topologies and to adapt to various requirements. This memo only
          specifies NTS for NTP modes 3 (client) and 4 (server) (see
          <xref target="sec-protocol-overview" />). The best current practice for
          authenticating the other NTP modes is using the symmetric message
          authentication code feature as described in
          <xref target="RFC5905">RFC 5905</xref> and
          <xref target="RFC8573">RFC 8573</xref>.
        </t>
      </section>
      <section title="Key Compromise">
        <t>
          If the suggested format
          for NTS cookies in <xref target="suggested-format-for-nts-cookies" />
          of this draft is used, an attacker who has gained
          access to the secret cookie encryption key `K` can impersonate
          the NTP server, including generating new cookies.
          NTP and NTS-KE server operators SHOULD remove compromised keys as soon
          as the compromise is discovered. This will cause the NTP servers to
          respond with NTS NAK, thus forcing key renegotiation. Note that this
          measure does not protect against MITM attacks where the attacker has access
          to a compromised cookie encryption key. If another cookie scheme is used,
          there are likely similar considerations for that particular scheme.
        </t>
      </section>
      <section title="Sensitivity to DDoS Attacks">
        <t>
          The introduction of NTS brings with it the introduction of asymmetric
          cryptography to NTP. Asymmetric cryptography is necessary for initial
          server authentication and AEAD key extraction. Asymmetric
          cryptosystems are generally orders of magnitude slower than their
          symmetric counterparts. This makes it much harder to build systems
          that can serve requests at a rate corresponding to the full line speed
          of the network connection. This, in turn, opens up a new possibility
          for DDoS attacks on NTP services.
        </t>
        <t>
          The main protection against these attacks in NTS lies in that the use
          of asymmetric cryptosystems is only necessary in the initial NTS-KE
          phase of the protocol. Since the protocol design enables separation of
          the NTS-KE and NTP servers, a successful DDoS attack on an NTS-KE
          server separated from the NTP service it supports will not affect NTP
          users that have already performed initial authentication, AEAD key
          extraction, and cookie exchange.
        </t>
        <t>
          NTS users should also consider that they are not fully protected
          against DoS attacks by on-path adversaries. In addition to dropping
          packets and attacks such as those described in
          <xref target="DelayAttack"/>, an on-path attacker can send spoofed
          kiss-o'-death replies, which are not authenticated, in response to NTP
          requests. This could result in significantly increased load on the
          NTS-KE server. Implementers have to weigh the user's need for
          unlinkability against the added resilience that comes with cookie
          reuse in cases of NTS-KE server unavailability.
        </t>
      </section>

      <section title="Avoiding DDoS Amplification">
        <t>
          Certain non-standard and/or deprecated features of the Network Time
          Protocol enable clients to send a request to a server which causes the
          server to send a response much larger than the request. Servers which
          enable these features can be abused in order to amplify traffic volume
          in DDoS attacks by sending them a request with a spoofed source IP. In
          recent years, attacks of this nature have become an endemic nuisance.
        </t>
        <t>
          NTS is designed to avoid contributing any further to this problem by
          ensuring that NTS-related extension fields included in server
          responses will be the same size as the NTS-related extension fields
          sent by the client. In particular, this is why the client is required
          to send a separate and appropriately padded-out NTS Cookie Placeholder
          extension field for every cookie it wants to get back, rather than
          being permitted simply to specify a desired quantity.
        </t>
        <t>
          Due to the <xref target="RFC7822">RFC 7822</xref> requirement that
          extensions be padded and aligned to four-octet boundaries, response
          size may still in some cases exceed request size by up to three
          octets. This is sufficiently inconsequential that we have declined to
          address it.
        </t>
      </section>

      <section title="Initial Verification of Server Certificates">
        <t>
          NTS's security goals are undermined if the client fails to verify that
          the X.509 certificate chain presented by the NTS-KE server is valid
          and rooted in a trusted certificate authority. <xref
          target="RFC5280">RFC 5280</xref> and <xref target="RFC6125"> RFC
          6125</xref> specify how such verification is to be performed in
          general. However, the expectation that the client does not yet have a
          correctly-set system clock at the time of certificate verification
          presents difficulties with verifying that the certificate is within
          its validity period, i.e., that the current time lies between the
          times specified in the certificate's notBefore and notAfter fields. It
          may be operationally necessary in some cases for a client to accept a
          certificate which appears to be expired or not yet valid. While there
          is no perfect solution to this problem, there are several mitigations
          the client can implement to make it more difficult for an adversary to
          successfully present an expired certificate:
          <list>
            <t>
              Check whether the system time is in fact unreliable. If the
              system clock has previously been synchronized since last boot,
              then on operating systems which implement the ntp_adjtime()
              system call, it will return a value other than TIME_ERROR. In
              this case, the clock SHOULD be considered reliable and
              certificates can be strictly validated.
            </t>
            <t>
              Allow the system administrator to specify that certificates should
              *always* be strictly validated. Such a configuration is
              appropriate on systems which have a battery-backed clock and which
              can reasonably prompt the user to manually set an
              approximately-correct time if it appears to be needed.
            </t>
            <t>
              Once the clock has been synchronized, periodically write the
              current system time to persistent storage. Do not accept any
              certificate whose notAfter field is earlier than the last recorded
              time.
            </t>
            <t>
              NTP time replies are expected to be consistent with the NTS-KE TLS
              certificate validity period, i.e. time replies received immediately after
              an NTS-KE handshake are expected to lie within the certificate validity
              period.
              Implementations are recommended to check that this is the case.
              Performing a new NTS-KE handshake based solely on the fact that the
              certificate used by the NTS-KE server in a previous handshake has expired
              is normally not necessary.
              Clients that still wish to do this must take care not to cause an
              inadvertent denial-of-service attack on the NTS-KE server, for example by
              picking a random time in the week preceding certificate expiry to perform
              the new handshake.
            </t>
            <t>
              Use multiple time sources. The ability to pass off an expired
              certificate is only useful to an adversary who has compromised the
              corresponding private key. If the adversary has compromised only a
              minority of servers, NTP's selection algorithm (<xref
              target="RFC5905">RFC 5905 section 11.2.1</xref>) will protect the
              client from accepting bad time from the adversary-controlled
              servers.
            </t>
          </list>
        </t>
      </section>

      <section anchor="DelayAttack" title="Delay Attacks">
        <t>
          In a packet delay attack, an adversary with the ability to act as a
          man-in-the-middle delays time synchronization packets between client
          and server asymmetrically <xref target="RFC7384"/>. Since NTP's
          formula for computing time offset relies on the assumption that
          network latency is roughly symmetrical, this leads to the client to
          compute an inaccurate value <xref target="Mizrahi"/>. The delay attack
          does not reorder or modify the content of the exchanged
          synchronization packets. Therefore, cryptographic means do not provide
          a feasible way to mitigate this attack. However, the maximum error
          that an adversary can introduce is bounded by half of the round trip
          delay.
        </t>
        <t>
          <xref target="RFC5905">RFC 5905</xref> specifies a parameter called
          MAXDIST which denotes the maximum round-trip latency (including not
          only the immediate round trip between client and server, but the whole
          distance back to the reference clock as reported in the Root Delay
          field) that a client will tolerate before concluding that the server
          is unsuitable for synchronization. The standard value for MAXDIST is
          one second, although some implementations use larger values. Whatever
          value a client chooses, the maximum error which can be introduced by a
          delay attack is MAXDIST/2.
        </t>
        <t>
          Usage of multiple time sources, or multiple network paths to a given
          time source <xref target="Shpiner"/>, may also serve to mitigate delay
          attacks if the adversary is in control of only some of the paths.
        </t>
      </section>
      <section title="NTS Stripping">
        <t>
          Implementers must be aware of the possibility of "NTS stripping"
          attacks, where an attacker tricks clients into reverting to plain
          NTP. Naive client implementations might, for example, revert
          automatically to plain NTP if the NTS-KE handshake fails. A man-in-the-middle
          attacker can easily cause this to happen. Even clients that already
          hold valid cookies can be vulnerable, since an attacker can force a
          client to repeat the NTS-KE handshake by sending faked NTP mode 4
          replies with the NTS NAK kiss code. Forcing a client to repeat the
          NTS-KE handshake can also be the first step in more advanced attacks.
        </t>
        <t>
          For the reasons described here, implementations SHOULD NOT revert
          from NTS-protected to unprotected NTP with any server without
          explicit user action.
        </t>
      </section>
    </section>

    <section title="Privacy Considerations">
      <section title="Unlinkability" anchor="Unlinkability">
        <t>Unlinkability prevents a device from being tracked when it changes
        network addresses (e.g. because said device moved between different
        networks). In other words, unlinkability thwarts an attacker that
        seeks to link a new network address used by a device with a network
        address that it was formerly using, because of recognizable data that
        the device persistently sends as part of an NTS-secured NTP
        association. This is the justification for continually supplying the
        client with fresh cookies, so that a cookie never represents
        recognizable data in the sense outlined above. </t>

        <t>NTS's unlinkability objective is merely to not leak any additional
        data that could be used to link a device's network address. NTS does
        not rectify legacy linkability issues that are already present in NTP.
        Thus, a client that requires unlinkability must also minimize
        information transmitted in a client query (mode 3) packet as described
        in the draft <xref target="I-D.ietf-ntp-data-minimization"/>.
        </t>

        <t>The unlinkability objective only holds for time synchronization
        traffic, as opposed to key exchange traffic. This implies that it
        cannot be guaranteed for devices that function not only as time
        clients, but also as time servers (because the latter can be externally
        triggered to send linkable data, such as the TLS certificate).</t>

        <t>It should also be noted that it could be possible to link devices
        that operate as time servers from their time synchronization traffic,
        using information exposed in (mode 4) server response packets (e.g.
        reference ID, reference time, stratum, poll).&nbsp; Also, devices that
        respond to NTP control queries could be linked using the information
        revealed by control queries. </t>
        
        <t>Note that the unlinkability objective does not prevent a client device
        to be tracked by its time servers.</t>
      </section>
      <section title="Confidentiality">
	<t>
	  NTS does not protect the confidentiality of information in
	  NTP's header fields. When clients implement <xref
	  target="I-D.ietf-ntp-data-minimization"/>, client packet
	  headers do not contain any information which the client
	  could conceivably wish to keep secret: one field is random,
	  and all others are fixed. Information in server packet
	  headers is likewise public: the origin timestamp is copied
	  from the client's (random) transmit timestamp, and all other
	  fields are set the same regardless of the identity of the
	  client making the request.
	</t>
	<t>
	  Future extension fields could hypothetically contain
	  sensitive information, in which case NTS provides a
	  mechanism for encrypting them.
	</t>
      </section>


    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The authors would like to thank Richard Barnes, Steven
      Bellovin, Scott Fluhrer, Patrik F&auml;ltstr&ouml;m (Faltstrom),
      Sharon Goldberg, Russ Housley, Benjamin Kaduk, Suresh Krishnan, Mirja
      K&uuml;hlewind (Kuehlewind), Martin Langer, Barry Leiba, Miroslav Lichvar,
      Aanchal Malhotra, Danny Mayer, Dave Mills, Sandra Murphy, Hal Murray,
      Karen O'Donoghue, Eric K. Rescorla, Kurt Roeckx, Stephen Roettger, Dan
      Romascanu, Kyle Rose, Rich Salz, Brian Sniffen, Susan Sons, Douglas
      Stebila, Harlan Stenn, Joachim Str&ouml;mbergsson (Strombergsson), Martin
      Thomson, &Eacute;ric (Eric) Vyncke, Richard Welty, Christer Weinigel, and
      Magnus Westerlund for contributions to this document and comments on the
      design of NTS.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="IANA-AEAD" target="https://www.iana.org/assignments/aead-parameters/">
        <front>
          <title>
            Authenticated Encryption with Associated Data (AEAD) Parameters
          </title>
          <author>
            <organization>IANA</organization>
          </author>
          <date />
        </front>
      </reference>
      <?rfc include='reference.RFC.0020.xml'?>
      <?rfc include='reference.RFC.2119.xml'?>
      <?rfc include='reference.RFC.4291.xml'?>
      <?rfc include='reference.RFC.5116.xml'?>
      <?rfc include="reference.RFC.5280.xml'?>
      <?rfc include='reference.RFC.5297.xml'?>
      <?rfc include='reference.RFC.5705.xml'?>
      <?rfc include='reference.RFC.5869.xml'?>
      <?rfc include='reference.RFC.5890.xml'?>
      <?rfc include='reference.RFC.5905.xml'?>
      <?rfc include='reference.RFC.6125.xml'?>
      <?rfc include='reference.RFC.6335.xml'?>
      <?rfc include='reference.RFC.6874.xml'?>
      <?rfc include='reference.RFC.7301.xml'?>
      <?rfc include='reference.RFC.7525.xml'?>
      <?rfc include='reference.RFC.7822.xml'?>
      <?rfc include='reference.RFC.8174.xml'?>
      <?rfc include='reference.RFC.8446.xml'?>
    </references>

    <references title="Informative References">
      <?rfc include='reference.I-D.draft-ietf-ntp-data-minimization-04.xml'?>
      <?rfc include='reference.RFC.4086.xml'?>
      <?rfc include='reference.RFC.5077.xml'?>
      <?rfc include='reference.RFC.7384.xml'?>
      <?rfc include='reference.RFC.8573.xml'?>
      <reference anchor="Mizrahi" target="">
        <front>
          <title>A game theoretic analysis of delay attacks against time
          synchronization protocols</title>

          <author fullname="Tal Mizrahi" initials="T" surname="Mizrahi">
            <organization abbrev=""/>
          </author>

          <date day="" month="September" year="2012"/>
        </front>

        <seriesInfo name="in Proceedings of"
                    value="Precision Clock Synchronization for Measurement Control and Communication, ISPCS 2012, pp. 1-6, DOI&nbsp;10.1109/ISPCS.2012.6336612"/>
      </reference>

      <reference anchor="Shpiner">
        <front>
          <title>Multi-path Time Protocols</title>

          <author fullname="Alexander Shpiner" initials="A" surname="Shpiner">
            <organization/>
          </author>
          <author fullname="Yoram Revah" initials="Y" surname="Revah">
            <organization/>
          </author>
          <author fullname="Tal Mizrahi" initials="T" surname="Mizrahi">
            <organization/>
          </author>

          <date month="September" year="2013"/>
        </front>

        <seriesInfo name="in Proceedings of"
                    value="IEEE International Symposium on Precision Clock Synchronization for Measurement, Control and Communication (ISPCS), DOI&nbsp;10.1109/ISPCS.2013.6644754"/>
      </reference>
    </references>

    <section title="Terms and Abbreviations">
      <t>
        <list style="hanging">
          <t hangText="AEAD  "><xref target="RFC5116">Authenticated Encryption
            with Associated Data</xref></t>
          <t hangText="ALPN  "><xref target="RFC7301">Application-Layer Protocol
            Negotiation</xref></t>
          <t hangText="C2S   ">Client-to-server</t>
          <t hangText="DoS   ">Denial-of-Service</t>
          <t hangText="DDoS  ">Distributed Denial-of-Service</t>
          <t hangText="EF    "><xref target="RFC5905">Extension Field</xref></t>
          <t hangText="HKDF  "><xref target="RFC5869">Hashed Message
            Authentication Code-based Key Derivation Function</xref></t>
          <t hangText="KoD   "><xref target="RFC5905">Kiss-o'-Death</xref></t>
          <t hangText="NTP   "><xref target="RFC5905">Network Time Protocol
            </xref></t>
          <t hangText="NTS   ">Network Time Security</t>
          <t hangText="NTS NAK">NTS negative-acknowledgment</t>
          <t hangText="NTS-KE">Network Time Security Key Exchange</t>
          <t hangText="PRF   ">Pseudorandom Function</t>
          <t hangText="S2C   ">Server-to-client</t>
          <t hangText="TLS   "><xref target="RFC8446">Transport Layer
            Security</xref></t>
        </list>
      </t>
    </section>
  </back>
</rfc>
